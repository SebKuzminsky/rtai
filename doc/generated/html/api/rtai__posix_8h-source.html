<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_posix.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a></div>
<h1>rtai_posix.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment"> * License as published by the Free Software Foundation; either</span>
00007 <span class="comment"> * version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment"> * Lesser General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
00015 <span class="comment"> * License along with this library; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> */</span>
00019 
00020 <span class="preprocessor">#ifndef _RTAI_POSIX_H_</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_POSIX_H_</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#ifdef __KERNEL__</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include &lt;rtai_malloc.h&gt;</span>
00026 <span class="preprocessor">#include &lt;rtai_rwl.h&gt;</span>
00027 <span class="preprocessor">#include &lt;rtai_spl.h&gt;</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00029 
00030 <span class="preprocessor">#define MAX_PRIO       99</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define MIN_PRIO       1</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define STACK_SIZE     8192</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define RR_QUANTUM_NS  1000000</span>
00034 <span class="preprocessor"></span>
00035 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore sem_t;
00036 
00037 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore pthread_mutex_t;
00038 
00039 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pthread_mutexattr_t;
00040 
00041 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore pthread_cond_t;
00042 
00043 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pthread_condattr_t;
00044 
00045 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_semaphore pthread_barrier_t;
00046 
00047 <span class="keyword">typedef</span> <span class="keywordtype">int</span> pthread_barrierattr_t;
00048 
00049 <span class="keyword">typedef</span> RWL pthread_rwlock_t;
00050 
00051 <span class="keyword">typedef</span> <span class="keywordtype">int</span> pthread_rwlockattr_t;
00052 
00053 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_spl_t pthread_spinlock_t;
00054 
00055 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct *pthread_t;
00056 
00057 <span class="keyword">typedef</span> <span class="keyword">struct </span>pthread_attr {
00058 
00059     <span class="keywordtype">int</span> stacksize;
00060     <span class="keywordtype">int</span> policy;
00061     <span class="keywordtype">int</span> rr_quantum_ns;
00062     <span class="keywordtype">int</span> priority;
00063 
00064 } pthread_attr_t;
00065 
00066 <span class="keyword">typedef</span> <span class="keyword">struct </span>pthread_cookie {
00067 
00068     RT_TASK task;
00069     SEM sem;
00070     void (*task_fun)(int);
00071     <span class="keywordtype">int</span> arg;
00072 
00073 } pthread_cookie_t;
00074 
00075 <span class="preprocessor">#ifdef __cplusplus</span>
00076 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00077 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00078 
00079 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_init_rt(sem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
00080 {
00081         <span class="keywordflow">if</span> (value &lt; SEM_TIMOUT) {
00082                 <a class="code" href="group__sem.html#ga2">rt_typed_sem_init</a>(sem, value, pshared | PRIO_Q);
00083                 <span class="keywordflow">return</span> 0;
00084         }
00085         <span class="keywordflow">return</span> -EINVAL;
00086 }
00087 
00088 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_destroy_rt(sem_t *sem)
00089 {
00090         <span class="keywordflow">if</span> (<a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(sem) &gt;= 0) {
00091                 <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(sem);
00092                 <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga4">rt_sem_delete</a>(sem);
00093         }
00094         <span class="keywordflow">return</span> -EBUSY;
00095 }
00096 
00097 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_wait_rt(sem_t *sem)
00098 {
00099         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga8">rt_sem_wait</a>(sem) &lt; SEM_TIMOUT ? 0 : -1;
00100 }
00101 
00102 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_trywait_rt(sem_t *sem)
00103 {
00104         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(sem) &gt; 0 ? 0 : -EAGAIN;
00105 }
00106 
00107 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_timedwait_rt(sem_t *sem, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)
00108 {
00109         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga10">rt_sem_wait_until</a>(sem, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00110 }
00111 
00112 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_post_rt(sem_t *sem)
00113 {
00114         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(sem) &lt; SEM_TIMOUT ? 0 : -ERANGE;
00115 }
00116 
00117 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> sem_getvalue_rt(sem_t *sem, <span class="keywordtype">int</span> *sval)
00118 {
00119         <span class="keywordflow">if</span> ((*sval = <a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(sem)) &gt; 0) {
00120                 <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(sem);
00121         }
00122         <span class="keywordflow">return</span> 0;
00123 }
00124 
00125 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_init_rt(pthread_mutex_t *mutex, <span class="keyword">const</span> pthread_mutexattr_t *mutexattr)
00126 {
00127         <a class="code" href="group__sem.html#ga2">rt_typed_sem_init</a>(mutex, 1, RES_SEM);
00128         <span class="keywordflow">return</span> 0;
00129 }
00130 
00131 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_destroy_rt(pthread_mutex_t *mutex)
00132 {
00133         <span class="keywordflow">if</span> (<a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(mutex) &gt; 0) {
00134                 <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(mutex);
00135                 <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga4">rt_sem_delete</a>(mutex);
00136         }
00137         <span class="keywordflow">return</span> -EBUSY;
00138 }
00139 
00140 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_lock_rt(pthread_mutex_t *mutex)
00141 {
00142         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga8">rt_sem_wait</a>(mutex) &lt; SEM_TIMOUT ? 0 : -EINVAL;
00143 }
00144 
00145 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_timedlock_rt(pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)
00146 {
00147         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga10">rt_sem_wait_until</a>(mutex, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -1;
00148 }
00149 
00150 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_trylock_rt(pthread_mutex_t *mutex)
00151 {
00152         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>(mutex) &gt; 0 ? 0 : -EBUSY;
00153 }
00154 
00155 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_mutex_unlock_rt(pthread_mutex_t *mutex)
00156 {
00157         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga6">rt_sem_signal</a>(mutex) &gt; 0 ? 0 : -EINVAL;
00158 }
00159 
00160 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_init_rt(pthread_cond_t *cond, <span class="keyword">const</span> pthread_condattr_t *cond_attr)
00161 {
00162         <span class="keywordflow">return</span> sem_init_rt(cond, BIN_SEM, 0);
00163 }
00164 
00165 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_destroy_rt(pthread_cond_t *cond)
00166 {
00167         <span class="keywordflow">return</span> sem_destroy_rt((sem_t *)cond);
00168 }
00169 
00170 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_signal_rt(pthread_cond_t *cond)
00171 {
00172         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga13">rt_cond_signal</a>((sem_t *)cond);
00173 }
00174 
00175 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_broadcast_rt(pthread_cond_t *cond)
00176 {
00177         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga7">rt_sem_broadcast</a>(cond);
00178 }
00179 
00180 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_wait_rt(pthread_cond_t *cond, pthread_mutex_t *mutex)
00181 {
00182         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga15">rt_cond_wait</a>(cond, mutex);
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cond_timedwait_rt(pthread_cond_t *cond, pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)
00186 {
00187         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga16">rt_cond_wait_until</a>(cond, mutex, timespec2count(abstime)) &lt; SEM_TIMOUT ? 0 : -ETIMEDOUT;
00188 }
00189 
00190 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_barrier_init_rt(pthread_barrier_t *barrier, <span class="keyword">const</span> pthread_barrierattr_t *attr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count)
00191 {
00192         <span class="keywordflow">return</span> sem_init_rt(barrier, CNT_SEM, count);
00193 }
00194 
00195 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_barrier_destroy_rt(pthread_barrier_t *barrier)
00196 {
00197         <span class="keywordflow">return</span> sem_destroy_rt(barrier);
00198 }
00199 
00200 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_barrier_wait_rt(pthread_barrier_t *barrier)
00201 {
00202         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga12">rt_sem_wait_barrier</a>(barrier);
00203 }
00204 
00205 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_init_rt(pthread_rwlock_t *rwlock, <span class="keyword">const</span> pthread_rwlockattr_t *attr)
00206 {
00207         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga18">rt_rwl_init</a>((RWL *)rwlock);
00208 }
00209 
00210 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_destroy_rt(pthread_rwlock_t *rwlock)
00211 {
00212         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga19">rt_rwl_delete</a>((RWL *)rwlock);
00213 }
00214 
00215 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_rdlock_rt(pthread_rwlock_t *rwlock)
00216 {
00217         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga20">rt_rwl_rdlock</a>((RWL *)rwlock);
00218 }
00219 
00220 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_tryrdlock_rt(pthread_rwlock_t *rwlock)
00221 {
00222         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga21">rt_rwl_rdlock_if</a>((RWL *)rwlock);
00223 }
00224 
00225 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_timedrdlock_rt(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime)
00226 {
00227         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga22">rt_rwl_rdlock_until</a>((RWL *)rwlock, timespec2count(abstime));
00228 }
00229 
00230 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_wrlock_rt(pthread_rwlock_t *rwlock)
00231 {
00232         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga24">rt_rwl_wrlock</a>((RWL *)rwlock);
00233 }
00234 
00235 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_trywrlock_rt(pthread_rwlock_t *rwlock)
00236 {
00237         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga25">rt_rwl_wrlock_if</a>((RWL *)rwlock);
00238 }
00239 
00240 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_timedwrlock_rt(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime)
00241 {
00242         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga26">rt_rwl_wrlock_until</a>((RWL *)rwlock, timespec2count(abstime));
00243 }
00244 
00245 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_rwlock_unlock_rt(pthread_rwlock_t *rwlock)
00246 {
00247         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga28">rt_rwl_unlock</a>((RWL *)rwlock);
00248 }
00249 
00250 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_init_rt(pthread_spinlock_t *lock)
00251 {
00252         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga29">rt_spl_init</a>((SPL *)lock);
00253 }
00254 
00255 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_destroy_rt(pthread_spinlock_t *lock)
00256 {
00257         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga30">rt_spl_delete</a>((SPL *)lock);
00258 }
00259 
00260 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_lock_rt(pthread_spinlock_t *lock)
00261 {
00262         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga31">rt_spl_lock</a>((SPL *)lock);
00263 }
00264 
00265 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_trylock_rt(pthread_spinlock_t *lock)
00266 {
00267         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga32">rt_spl_lock_if</a>((SPL *)lock);
00268 }
00269 
00270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_spin_unlock_rt(pthread_spinlock_t *lock)
00271 {
00272         <span class="keywordflow">return</span> <a class="code" href="group__sem.html#ga34">rt_spl_unlock</a>((SPL *)lock);
00273 }
00274 
00275 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> get_max_priority_rt(<span class="keywordtype">int</span> policy)
00276 {
00277         <span class="keywordflow">return</span> MAX_PRIO;
00278 }
00279 
00280 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> get_min_priority_rt(<span class="keywordtype">int</span> policy)
00281 {
00282         <span class="keywordflow">return</span> MIN_PRIO;
00283 }
00284 
00285 <span class="keyword">static</span> <span class="keywordtype">void</span> posix_wrapper_fun(pthread_cookie_t *cookie)
00286 {
00287         cookie-&gt;task_fun(cookie-&gt;arg);
00288         <a class="code" href="group__sem.html#ga7">rt_sem_broadcast</a>(&amp;cookie-&gt;sem);
00289         <a class="code" href="group__sem.html#ga4">rt_sem_delete</a>(&amp;cookie-&gt;sem);
00290         <a class="code" href="api_8c.html#a14">rt_task_suspend</a>(&amp;cookie-&gt;task);
00291 } 
00292 
00293 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_create_rt(pthread_t *thread, <span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">void</span> *(*start_routine)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg)
00294 {
00295         pthread_cookie_t *cookie;
00296         cookie = (<span class="keywordtype">void</span> *)rt_malloc(<span class="keyword">sizeof</span>(pthread_cookie_t));
00297         <span class="keywordflow">if</span> (cookie) {
00298                 (cookie-&gt;task).magic = 0;
00299                 cookie-&gt;task_fun = (<span class="keywordtype">void</span> *)start_routine;
00300                 cookie-&gt;arg = (int)arg;
00301                 <span class="keywordflow">if</span> (!<a class="code" href="group__lxrt.html#ga6">rt_task_init</a>(&amp;cookie-&gt;task, (<span class="keywordtype">void</span> *)posix_wrapper_fun, (<span class="keywordtype">int</span>)cookie,
00302                                 (attr) ? attr-&gt;stacksize : STACK_SIZE, (attr) ? attr-&gt;priority : RT_SCHED_LOWEST_PRIORITY, 1, 0)) {
00303                         *thread = &amp;cookie-&gt;task;
00304                         <a class="code" href="group__sem.html#ga2">rt_typed_sem_init</a>(&amp;cookie-&gt;sem, 0, BIN_SEM | FIFO_Q);
00305                         <a class="code" href="api_8c.html#a18">rt_task_resume</a>(&amp;cookie-&gt;task);
00306                         <span class="keywordflow">return</span> 0;
00307                 }
00308         }
00309         rt_free(cookie);
00310         <span class="keywordflow">return</span> ENOMEM;
00311 }
00312 
00313 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_yield_rt(<span class="keywordtype">void</span>)
00314 {
00315         <a class="code" href="api_8c.html#a13">rt_task_yield</a>();
00316         <span class="keywordflow">return</span> 0;
00317 }
00318 
00319 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> pthread_exit_rt(<span class="keywordtype">void</span> *retval)
00320 {
00321         RT_TASK *rt_task;
00322         rt_task = <a class="code" href="api_8c.html#a12">rt_whoami</a>();
00323         <a class="code" href="group__sem.html#ga7">rt_sem_broadcast</a>((SEM *)(rt_task + 1));
00324         <a class="code" href="group__sem.html#ga4">rt_sem_delete</a>((SEM *)(rt_task + 1));
00325         <a class="code" href="api_8c.html#a14">rt_task_suspend</a>(rt_task);
00326 }
00327 
00328 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_join_rt(pthread_t thread, <span class="keywordtype">void</span> **thread_return)
00329 {
00330         <span class="keywordtype">int</span> retval1, retval2;
00331         <span class="keywordflow">if</span> (<a class="code" href="api_8c.html#a12">rt_whoami</a>()-&gt;priority != RT_SCHED_LINUX_PRIORITY)
00332                 retval1 = <a class="code" href="group__sem.html#ga8">rt_sem_wait</a>((SEM *)(thread + 1));
00333         <span class="keywordflow">else</span> {
00334                 <span class="keywordflow">while</span> ((retval1 = <a class="code" href="group__sem.html#ga9">rt_sem_wait_if</a>((SEM *)(thread + 1))) &lt;= 0) {
00335                         set_current_state(TASK_INTERRUPTIBLE);
00336                         schedule_timeout(HZ/10);
00337                 }
00338         }
00339         <span class="keywordflow">if</span> (retval1 != 0xFFFF)
00340                 retval1 = 0;
00341         retval2 = rt_task_delete(thread);
00342         rt_free(thread);
00343         <span class="keywordflow">return</span> (retval1) ? retval1 : retval2;
00344 }
00345 
00346 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_cancel_rt(pthread_t thread)
00347 {
00348         <span class="keywordtype">int</span> retval;
00349         <span class="keywordflow">if</span> (!thread) {
00350                 thread = <a class="code" href="api_8c.html#a12">rt_whoami</a>();
00351         }
00352         retval = rt_task_delete(thread);
00353         rt_free(thread);
00354         <span class="keywordflow">return</span> retval;
00355 }
00356 
00357 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_equal_rt(pthread_t thread1,pthread_t thread2)
00358 {
00359         <span class="keywordflow">return</span> thread1 == thread2;
00360 }
00361 
00362 <span class="keyword">static</span> <span class="keyword">inline</span> pthread_t pthread_self_rt(<span class="keywordtype">void</span>)
00363 {
00364         <span class="keywordflow">return</span> <a class="code" href="api_8c.html#a12">rt_whoami</a>();
00365 }
00366 
00367 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_init_rt(pthread_attr_t *attr)
00368 {
00369         attr-&gt;stacksize     = STACK_SIZE;
00370         attr-&gt;policy        = SCHED_FIFO;
00371         attr-&gt;rr_quantum_ns = RR_QUANTUM_NS;
00372         attr-&gt;priority      = 1;
00373         <span class="keywordflow">return</span> 0;
00374 }
00375 
00376 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_destroy_rt(pthread_attr_t *attr)
00377 {
00378         <span class="keywordflow">return</span> 0;
00379 }
00380 
00381 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setschedparam_rt(pthread_attr_t *attr, <span class="keyword">const</span> <span class="keyword">struct</span> sched_param *param)
00382 {
00383         <span class="keywordflow">if</span>(param-&gt;sched_priority &lt; MIN_PRIO || param-&gt;sched_priority &gt; MAX_PRIO) {
00384                 <span class="keywordflow">return</span>(EINVAL);
00385         }
00386         attr-&gt;priority = MAX_PRIO - param-&gt;sched_priority;
00387         <span class="keywordflow">return</span> 0;
00388 }
00389 
00390 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getschedparam_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keyword">struct</span> sched_param *param)
00391 {
00392         param-&gt;sched_priority = MAX_PRIO - attr-&gt;priority;
00393         <span class="keywordflow">return</span> 0;
00394 }
00395 
00396 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setschedpolicy_rt(pthread_attr_t *attr, <span class="keywordtype">int</span> policy)
00397 {
00398         <span class="keywordflow">if</span>(policy != SCHED_FIFO &amp;&amp; policy != SCHED_RR) {
00399                 <span class="keywordflow">return</span> EINVAL;
00400         }
00401         <span class="keywordflow">if</span> ((attr-&gt;policy = policy) == SCHED_RR) {
00402                 rt_set_sched_policy(<a class="code" href="api_8c.html#a12">rt_whoami</a>(), SCHED_RR, attr-&gt;rr_quantum_ns);
00403         }
00404         <span class="keywordflow">return</span> 0;
00405 }
00406 
00407 
00408 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getschedpolicy_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">int</span> *policy)
00409 {
00410         *policy = attr-&gt;policy;
00411         <span class="keywordflow">return</span> 0;
00412 }
00413 
00414 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setschedrr_rt(pthread_attr_t *attr, <span class="keywordtype">int</span> rr_quantum_ns)
00415 {
00416         attr-&gt;rr_quantum_ns = rr_quantum_ns;
00417         <span class="keywordflow">return</span> 0;
00418 }
00419 
00420 
00421 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getschedrr_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">int</span> *rr_quantum_ns)
00422 {
00423         *rr_quantum_ns = attr-&gt;rr_quantum_ns;
00424         <span class="keywordflow">return</span> 0;
00425 }
00426 
00427 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setstacksize_rt(pthread_attr_t *attr, <span class="keywordtype">int</span> stacksize)
00428 {
00429         attr-&gt;stacksize = stacksize;
00430         <span class="keywordflow">return</span> 0;
00431 }
00432 
00433 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getstacksize_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">int</span> *stacksize)
00434 {
00435         *stacksize = attr-&gt;stacksize;
00436         <span class="keywordflow">return</span> 0;
00437 }
00438 
00439 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_setstack_rt(pthread_attr_t *attr, <span class="keywordtype">void</span> *stackaddr, <span class="keywordtype">int</span> stacksize)
00440 {
00441         attr-&gt;stacksize = stacksize;
00442         <span class="keywordflow">return</span> 0;
00443 }
00444 
00445 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> pthread_attr_getstack_rt(<span class="keyword">const</span> pthread_attr_t *attr, <span class="keywordtype">void</span> **stackaddr, <span class="keywordtype">int</span> *stacksize)
00446 {
00447         *stacksize = attr-&gt;stacksize;
00448         <span class="keywordflow">return</span> 0;
00449 }
00450 
00451 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> pthread_testcancel_rt(<span class="keywordtype">void</span>)
00452 {
00453         rt_task_delete(<a class="code" href="api_8c.html#a12">rt_whoami</a>());
00454         pthread_exit_rt(NULL);
00455 }
00456 
00457 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> clock_gettime_rt(<span class="keywordtype">int</span> clockid, <span class="keyword">struct</span> timespec *current_time)
00458 {
00459         count2timespec(rt_get_time(), current_time);
00460 }
00461 
00462 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> nanosleep_rt(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *rqtp, <span class="keyword">struct</span> timespec *rmtp)
00463 {
00464         RTIME expire;
00465         <span class="keywordflow">if</span> (rqtp-&gt;tv_nsec &gt;= 1000000000L || rqtp-&gt;tv_nsec &lt; 0 || rqtp-&gt;tv_sec &lt;
00466 0) {
00467                 <span class="keywordflow">return</span> -EINVAL;
00468         }
00469         <a class="code" href="api_8c.html#a33">rt_sleep_until</a>(expire = rt_get_time() + timespec2count(rqtp));
00470         <span class="keywordflow">if</span> ((expire -= rt_get_time()) &gt; 0) {
00471                 <span class="keywordflow">if</span> (rmtp) {
00472                         count2timespec(expire, rmtp);
00473                 }
00474                 <span class="keywordflow">return</span> -EINTR;
00475         }
00476         <span class="keywordflow">return</span> 0;
00477 }
00478 
00479 <span class="comment">/*</span>
00480 <span class="comment"> * DO NOTHING FUNCTIONS</span>
00481 <span class="comment"> */</span>
00482 
00483 <span class="preprocessor">#define pthread_mutexattr_init_rt(attr)</span>
00484 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_destroy_rt(attr)</span>
00485 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_getpshared_rt(attr, pshared)</span>
00486 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_setpshared_rt(attr, pshared)</span>
00487 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_settype_rt(attr, kind)</span>
00488 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_gettype_rt(attr, kind)</span>
00489 <span class="preprocessor"></span>
00490 <span class="preprocessor">#define pthread_condattr_init_rt(attr)</span>
00491 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_destroy_rt(attr)</span>
00492 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_getpshared_rt(attr, pshared)</span>
00493 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_setpshared_rt(attr, pshared)</span>
00494 <span class="preprocessor"></span>
00495 <span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00496 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00497 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00498 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00499 <span class="preprocessor"></span>
00500 <span class="preprocessor">#define pthread_rwlockattr_init(attr)</span>
00501 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_destroy(attr)</span>
00502 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getpshared( ttr, pshared)</span>
00503 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setpshared(attr, pshared)</span>
00504 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getkind_np(attr, pref)</span>
00505 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setkind_np(attr, pref)</span>
00506 <span class="preprocessor"></span>
00507 <span class="preprocessor">#define pthread_detach_rt(thread)</span>
00508 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setdetachstate_rt(attr, detachstate)</span>
00509 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getdetachstate_rt(attr, detachstate)</span>
00510 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setconcurrency_rt(level)</span>
00511 <span class="preprocessor"></span><span class="preprocessor">#define pthread_getconcurrency_rt()</span>
00512 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setinheritsched_rt(attr, inherit)</span>
00513 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getinheritsched_rt(attr, inherit)</span>
00514 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setscope_rt(attr, scope)</span>
00515 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getscope_rt(attr, scope)</span>
00516 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setguardsize_rt(attr, guardsize) </span>
00517 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getguardsize_rt(attr, guardsize)</span>
00518 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstackaddr_rt(attr, stackaddr)</span>
00519 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstackaddr_rt(attr, stackaddr) </span>
00520 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setcancelstate_rt(state, oldstate)</span>
00521 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setcanceltype_rt(type, oldtype)</span>
00522 <span class="preprocessor"></span>
00523 <span class="preprocessor">#ifdef __cplusplus</span>
00524 <span class="preprocessor"></span>}
00525 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00526 
00527 <span class="preprocessor">#else  </span><span class="comment">/* !__KERNEL__ */</span>
00528 
00529 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00530 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00531 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00532 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00533 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00534 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00535 <span class="preprocessor">#include &lt;semaphore.h&gt;</span>
00536 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00537 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00538 
00539 <span class="keyword">struct </span>task_struct;
00540 
00541 <span class="preprocessor">#undef  SEM_VALUE_MAX </span>
00542 <span class="preprocessor"></span><span class="preprocessor">#define SEM_VALUE_MAX  (SEM_TIMOUT - 1)</span>
00543 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BINARY     (0x7FFFFFFF)</span>
00544 <span class="preprocessor"></span>
00545 <span class="preprocessor">#include &lt;asm/rtai_atomic.h&gt;</span>
00546 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00547 
00548 <span class="comment">/*</span>
00549 <span class="comment"> * SUPPORT STUFF</span>
00550 <span class="comment"> */</span>
00551 
00552 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> MAKE_SOFT(<span class="keywordtype">void</span>)
00553 {
00554         <span class="keywordflow">if</span> (rt_is_hard_real_time(rt_buddy())) {
00555                 <a class="code" href="group__lxrt.html#ga9">rt_make_soft_real_time</a>();
00556                 <span class="keywordflow">return</span> 1;
00557         }
00558         <span class="keywordflow">return</span> 0;
00559 }
00560 
00561 <span class="preprocessor">#define MAKE_HARD(hs)  do { if (hs) rt_make_hard_real_time(); } while (0)</span>
00562 <span class="preprocessor"></span>
00563 <span class="preprocessor">#ifdef __cplusplus</span>
00564 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00565 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00566 
00567 RTAI_PROTO(<span class="keywordtype">void</span>, count2timespec,(RTIME rt, <span class="keyword">struct</span> timespec *t))
00568 {
00569         t-&gt;tv_sec = (rt = count2nano(rt))/1000000000;
00570         t-&gt;tv_nsec = rt - t-&gt;tv_sec*1000000000LL;
00571 }
00572 
00573 RTAI_PROTO(<span class="keywordtype">void</span>, nanos2timespec,(RTIME rt, <span class="keyword">struct</span> timespec *t))
00574 {
00575         t-&gt;tv_sec = rt/1000000000;
00576         t-&gt;tv_nsec = rt - t-&gt;tv_sec*1000000000LL;
00577 }
00578 
00579 RTAI_PROTO(RTIME, timespec2count,(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t))
00580 {
00581         <span class="keywordflow">return</span> nano2count(t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec);
00582 }
00583 
00584 RTAI_PROTO(RTIME, timespec2nanos,(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t))
00585 {
00586         <span class="keywordflow">return</span> t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec;
00587 }
00588 
00589 <span class="comment">/*</span>
00590 <span class="comment"> * FUNCTIONS MADE SAFELY USABLE IN HARD REAL TIME, BUT BREAKING HARD REAL TIME</span>
00591 <span class="comment"> */</span>
00592 
00593 RTAI_PROTO(sem_t *,sem_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> oflags, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> type))
00594 {
00595         <span class="keywordtype">int</span> hs, fd;
00596         sem_t *sem;
00597         hs = MAKE_SOFT();
00598         <span class="keywordflow">if</span> ((fd = open(name, O_RDONLY)) &gt; 0) {
00599                 read(fd, &amp;sem, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00600                 close(fd); 
00601                 atomic_inc((atomic_t *)(&amp;((<span class="keywordtype">int</span> *)sem)[1]));
00602         } <span class="keywordflow">else</span> {
00603                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), value, (type == SEM_BINARY ? BIN_SEM : CNT_SEM) | PRIO_Q };
00604                 sem = (sem_t *)malloc(<span class="keyword">sizeof</span>(sem_t));
00605                 <span class="keywordflow">if</span> ((((<span class="keywordtype">int</span> *)sem)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW]) &amp;&amp; (fd = open(name, O_WRONLY | O_CREAT))) {
00606                         write(fd, &amp;sem, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00607                         close(fd); 
00608                         ((<span class="keywordtype">int</span> *)sem)[1] = 1;
00609                 } <span class="keywordflow">else</span> {
00610                         free(sem);
00611                         sem = 0;
00612                 }
00613         }
00614         MAKE_HARD(hs);
00615         <span class="keywordflow">return</span> sem;
00616 }
00617 
00618 RTAI_PROTO(<span class="keywordtype">int</span>, sem_init_rt,(sem_t *sem, <span class="keywordtype">int</span> pshared, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value))
00619 {
00620         <span class="keywordtype">int</span> hs;
00621         <span class="keywordflow">if</span> (value &lt;= SEM_VALUE_MAX) {
00622                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="group__lxrt.html#ga1">rt_get_name</a>(0), value, (pshared == SEM_BINARY ? BIN_SEM : CNT_SEM) | PRIO_Q };
00623                 hs = MAKE_SOFT();
00624                 ((<span class="keywordtype">int</span> *)sem)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW];
00625                 ((<span class="keywordtype">int</span> *)sem)[1] = 0;
00626                 MAKE_HARD(hs);
00627                 <span class="keywordflow">return</span> 0;
00628         }
00629         errno = EINVAL;
00630         <span class="keywordflow">return</span> -1;
00631 }
00632 
00633 RTAI_PROTO(<span class="keywordtype">int</span>, sem_close_rt,(sem_t *sem))
00634 {
00635         <span class="keywordtype">int</span> hs, cnt;
00636         <span class="keywordtype">char</span> name[7];
00637         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00638         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW] &lt; 0) {
00639                 errno = EBUSY;
00640                 <span class="keywordflow">return</span> -1;
00641         }
00642         cnt = ((<span class="keywordtype">int</span> *)sem)[1];
00643         <span class="keywordflow">if</span> (!cnt || (cnt &amp;&amp; atomic_dec_and_test((atomic_t *)&amp;((<span class="keywordtype">int</span> *)sem)[1]))) {
00644                 hs = MAKE_SOFT();
00645                 <a class="code" href="rtai__nam2num_8h.html#a1">num2nam</a>(<a class="code" href="group__lxrt.html#ga1">rt_get_name</a>(((<span class="keywordtype">void</span> **)sem)[0]), name);
00646                 rtai_lxrt(BIDX, SIZARG, LXRT_SEM_DELETE, &amp;arg);
00647                 <span class="keywordflow">if</span> (cnt) {
00648                         unlink(name);
00649                         free((<span class="keywordtype">void</span> *)sem);
00650                 }
00651                 MAKE_HARD(hs);
00652         }
00653         <span class="keywordflow">return</span> 0;
00654 }
00655 
00656 RTAI_PROTO(<span class="keywordtype">int</span>, sem_destroy_rt,(sem_t *sem))
00657 {
00658         <span class="keywordflow">return</span> sem_close_rt(sem);
00659 }
00660 
00661 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_create_rt,(pthread_t *thread, pthread_attr_t *attr, <span class="keywordtype">void</span> *(*start_routine)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg))
00662 {
00663         <span class="keywordtype">int</span> hs, ret;
00664         hs = MAKE_SOFT();
00665         ret = pthread_create(thread, attr, start_routine, arg);
00666         MAKE_HARD(hs);
00667         <span class="keywordflow">return</span> ret;
00668 }
00669 
00670 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cancel_rt,(pthread_t thread))
00671 {
00672         <span class="keywordtype">int</span> hs, ret;
00673         hs = MAKE_SOFT();
00674         ret = pthread_cancel(thread);
00675         MAKE_HARD(hs);
00676         <span class="keywordflow">return</span> ret;
00677 }
00678 
00679 <span class="preprocessor">#define pthread_cleanup_push_rt(routine, arg) \</span>
00680 <span class="preprocessor">do { \</span>
00681 <span class="preprocessor">        {\</span>
00682 <span class="preprocessor">                int __hs_hs_hs__; \</span>
00683 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00684 <span class="preprocessor">                pthread_cleanup_push(routine, arg); \</span>
00685 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__);</span>
00686 <span class="preprocessor"></span>        
00687 <span class="preprocessor">#define pthread_cleanup_pop_rt(execute) \</span>
00688 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00689 <span class="preprocessor">                pthread_cleanup_pop(execute); \</span>
00690 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__); \</span>
00691 <span class="preprocessor">        } \</span>
00692 <span class="preprocessor">} while (0)</span>
00693 <span class="preprocessor"></span>
00694 <span class="preprocessor">#define pthread_cleanup_push_defer_rt(routine, arg) \</span>
00695 <span class="preprocessor">do { \</span>
00696 <span class="preprocessor">        {\</span>
00697 <span class="preprocessor">                int __hs_hs_hs__; \</span>
00698 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00699 <span class="preprocessor">                pthread_cleanup_push_defer_np(routine, arg); \</span>
00700 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__);</span>
00701 <span class="preprocessor"></span>
00702 <span class="preprocessor">#define pthread_cleanup_pop_restore_rt(execute) \</span>
00703 <span class="preprocessor">                __hs_hs_hs__ = MAKE_SOFT(); \</span>
00704 <span class="preprocessor">                pthread_cleanup_pop_restore_np(execute); \</span>
00705 <span class="preprocessor">                MAKE_HARD(__hs_hs_hs__); \</span>
00706 <span class="preprocessor">        } \</span>
00707 <span class="preprocessor">} while (0)</span>
00708 <span class="preprocessor"></span>
00709 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_sigmask_rt,(<span class="keywordtype">int</span> how, <span class="keyword">const</span> sigset_t *newmask, sigset_t *oldmask))
00710 {
00711         <span class="keywordtype">int</span> hs, ret;
00712         hs = MAKE_SOFT();
00713         ret = pthread_sigmask(how, newmask, oldmask);
00714         MAKE_HARD(hs);
00715         <span class="keywordflow">return</span> ret;
00716 }
00717 
00718 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_kill_rt,(pthread_t thread, <span class="keywordtype">int</span> signo))
00719 {
00720         <span class="keywordtype">int</span> hs, ret;
00721         hs = MAKE_SOFT();
00722         ret = pthread_kill(thread, signo);
00723         MAKE_HARD(hs);
00724         <span class="keywordflow">return</span> ret;
00725 }
00726 
00727 
00728 RTAI_PROTO(<span class="keywordtype">int</span>, sigwait_rt,(<span class="keyword">const</span> sigset_t *set, <span class="keywordtype">int</span> *sig))
00729 {
00730         <span class="keywordtype">int</span> hs, ret;
00731         hs = MAKE_SOFT();
00732         ret = sigwait(set, sig);
00733         MAKE_HARD(hs);
00734         <span class="keywordflow">return</span> ret;
00735 }
00736 
00737 RTAI_PROTO(pthread_mutex_t *, pthread_mutex_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00738 {
00739         <span class="keywordtype">int</span> hs, fd;
00740         pthread_mutex_t *mutex;
00741         hs = MAKE_SOFT();
00742         <span class="keywordflow">if</span> ((fd = open(name, O_RDONLY)) &gt; 0) {
00743                 read(fd, &amp;mutex, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00744                 close(fd); 
00745                 atomic_inc((atomic_t *)(&amp;((<span class="keywordtype">int</span> *)mutex)[1]));
00746         } <span class="keywordflow">else</span> {
00747                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), 1, RES_SEM };
00748                 mutex = (pthread_mutex_t *)malloc(<span class="keyword">sizeof</span>(pthread_mutex_t));
00749                 <span class="keywordflow">if</span> ((((<span class="keywordtype">int</span> *)mutex)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW]) &amp;&amp; (fd = open(name, O_WRONLY | O_CREAT))) {
00750                         write(fd, &amp;mutex, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00751                         close(fd); 
00752                         ((<span class="keywordtype">int</span> *)mutex)[1] = 1;
00753                 } <span class="keywordflow">else</span> {
00754                         free(mutex);
00755                         mutex = 0;
00756                 }
00757         }
00758         MAKE_HARD(hs);
00759         <span class="keywordflow">return</span> mutex;
00760 }
00761 
00762 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_init_rt,(pthread_mutex_t *mutex, <span class="keyword">const</span> pthread_mutexattr_t *mutexattr))
00763 {
00764         <span class="keywordtype">int</span> hs;
00765         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="group__lxrt.html#ga1">rt_get_name</a>(0), 1, RES_SEM };
00766         hs = MAKE_SOFT();
00767         ((<span class="keywordtype">int</span> *)mutex)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_SEM_INIT, &amp;arg).i[LOW];
00768         ((<span class="keywordtype">int</span> *)mutex)[1] = 0;
00769         MAKE_HARD(hs);
00770         <span class="keywordflow">return</span> 0;
00771 }
00772 
00773 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_close_rt,(pthread_mutex_t *mutex))
00774 {
00775         <span class="keywordtype">int</span> hs, cnt;
00776         <span class="keywordtype">char</span> name[7];
00777         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)mutex)[0] };
00778         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW] &lt; 0) {
00779                 <span class="keywordflow">return</span> EBUSY;
00780         }
00781         cnt = ((<span class="keywordtype">int</span> *)mutex)[1];
00782         <span class="keywordflow">if</span> (!cnt || (cnt &amp;&amp; atomic_dec_and_test((atomic_t *)&amp;((<span class="keywordtype">int</span> *)mutex)[1]))) {
00783                 hs = MAKE_SOFT();
00784                 <a class="code" href="rtai__nam2num_8h.html#a1">num2nam</a>(<a class="code" href="group__lxrt.html#ga1">rt_get_name</a>(((<span class="keywordtype">void</span> **)mutex)[0]), name);
00785                 rtai_lxrt(BIDX, SIZARG, LXRT_SEM_DELETE, &amp;arg);
00786                 <span class="keywordflow">if</span> (cnt) {
00787                         unlink(name);
00788                         free((<span class="keywordtype">void</span> *)mutex);
00789                 }
00790                 MAKE_HARD(hs);
00791         }
00792         <span class="keywordflow">return</span> 0;
00793 }
00794 
00795 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_destroy_rt,(pthread_mutex_t *mutex))
00796 {
00797         <span class="keywordflow">return</span> pthread_mutex_close_rt(mutex);
00798 }
00799 
00800 RTAI_PROTO(pthread_cond_t *, pthread_cond_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00801 {
00802         <span class="keywordflow">return</span> (pthread_cond_t *)sem_open_rt(name, 0, 0, SEM_BINARY);
00803 }
00804 
00805 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_init_rt,(pthread_cond_t *cond, pthread_condattr_t *cond_attr))
00806 {
00807         <span class="keywordflow">return</span> sem_init_rt((sem_t *)cond, SEM_BINARY, 0);
00808 }
00809 
00810 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_destroy_rt,(pthread_cond_t *cond))
00811 {
00812         <span class="keywordflow">return</span> sem_close_rt((sem_t *)cond);
00813 }
00814 
00815 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_close_rt,(pthread_cond_t *cond))
00816 {
00817         <span class="keywordflow">return</span> sem_close_rt((sem_t *)cond);
00818 }
00819 
00820 <span class="preprocessor">#ifdef __USE_XOPEN2K</span>
00821 <span class="preprocessor"></span>RTAI_PROTO(pthread_barrier_t *, pthread_barrier_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count))
00822 {
00823         <span class="keywordflow">return</span> (pthread_barrier_t *)sem_open_rt(name, 0, count, 0);
00824 }
00825 
00826 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_init_rt,(pthread_barrier_t *barrier, <span class="keyword">const</span> pthread_barrierattr_t *attr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count))
00827 {
00828         <span class="keywordflow">return</span> sem_init_rt((sem_t *)barrier, 0, count);
00829 }
00830 
00831 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_destroy_rt,(pthread_barrier_t *barrier))
00832 {
00833         <span class="keywordflow">return</span> sem_close_rt((sem_t *)barrier);
00834 }
00835 
00836 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_close_rt,(pthread_barrier_t *barrier))
00837 {
00838         <span class="keywordflow">return</span> sem_close_rt((sem_t *)barrier);
00839 }
00840 <span class="preprocessor">#endif</span>
00841 <span class="preprocessor"></span>
00842 <span class="comment">/*</span>
00843 <span class="comment"> * DO NOTHING FUNCTIONS (IN RTAI HARD REAL TIME)</span>
00844 <span class="comment"> */</span>
00845 
00846 <span class="preprocessor">#define pthread_attr_setdetachstate_rt(attr, detachstate)</span>
00847 <span class="preprocessor"></span><span class="preprocessor">#define pthread_detach_rt(thread)</span>
00848 <span class="preprocessor"></span><span class="preprocessor">#define pthread_getconcurrency_rt()</span>
00849 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setconcurrency_rt(level)</span>
00850 <span class="preprocessor"></span>
00851 <span class="preprocessor">#define pthread_mutexattr_init_rt(attr)</span>
00852 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_destroy_rt(attr)</span>
00853 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_getpshared_rt(attr, pshared)</span>
00854 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_setpshared_rt(attr, pshared)</span>
00855 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_settype_rt(attr, kind)</span>
00856 <span class="preprocessor"></span><span class="preprocessor">#define pthread_mutexattr_gettype_rt(attr, kind)</span>
00857 <span class="preprocessor"></span>
00858 <span class="preprocessor">#define pthread_condattr_init_rt(attr)</span>
00859 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_destroy_rt(attr)</span>
00860 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_getpshared_rt(attr, pshared)</span>
00861 <span class="preprocessor"></span><span class="preprocessor">#define pthread_condattr_setpshared_rt(attr, pshared)</span>
00862 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_XOPEN2K</span>
00863 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00864 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00865 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_getpshared_rt(attr, pshared)</span>
00866 <span class="preprocessor"></span><span class="preprocessor">#define pthread_barrierattr_setpshared_rt(attr, pshared)</span>
00867 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00868 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_init(attr)</span>
00869 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_destroy(attr)</span>
00870 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getpshared( ttr, pshared)</span>
00871 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setpshared(attr, pshared)</span>
00872 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_getkind_np(attr, pref)</span>
00873 <span class="preprocessor"></span><span class="preprocessor">#define pthread_rwlockattr_setkind_np(attr, pref)</span>
00874 <span class="preprocessor"></span>
00875 <span class="comment">/*</span>
00876 <span class="comment"> * FUNCTIONS (LIKELY) SAFELY USABLE IN HARD REAL TIME "AS THEY ARE", </span>
00877 <span class="comment"> * BECAUSE MAKE SENSE IN THE INITIALIZATION PHASE ONLY, I.E. BEFORE </span>
00878 <span class="comment"> * GOING HARD REAL TIME</span>
00879 <span class="comment"> */</span>
00880 
00881 <span class="preprocessor">#define pthread_self_rt                  pthread_self</span>
00882 <span class="preprocessor"></span><span class="preprocessor">#define pthread_equal_rt                 pthread_equal</span>
00883 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_init_rt             pthread_attr_init      </span>
00884 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_destroy_rt          pthread_attr_destroy</span>
00885 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getdetachstate_rt   pthread_attr_getdetachstate</span>
00886 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setschedpolicy_rt   pthread_attr_setschedpolicy</span>
00887 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getschedpolicy_rt   pthread_attr_getschedpolicy </span>
00888 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setschedparam_rt    pthread_attr_setschedparam</span>
00889 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getschedparam_rt    pthread_attr_getschedparam</span>
00890 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setinheritsched_rt  pthread_attr_setinheritsched</span>
00891 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getinheritsched_rt  pthread_attr_getinheritsched</span>
00892 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setscope_rt         pthread_attr_setscope</span>
00893 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getscope_rt         pthread_attr_getscope</span>
00894 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_UNIX98</span>
00895 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setguardsize_rt     pthread_attr_setguardsize</span>
00896 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getguardsize_rt     pthread_attr_getguardsize</span>
00897 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00898 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstackaddr_rt     pthread_attr_setstackaddr</span>
00899 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstackaddr_rt     pthread_attr_getstackaddr</span>
00900 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_XOPEN2K</span>
00901 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstack_rt         pthread_attr_setstack</span>
00902 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstack_rt         pthread_attr_getstack</span>
00903 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00904 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_setstacksize_rt     pthread_attr_setstacksize</span>
00905 <span class="preprocessor"></span><span class="preprocessor">#define pthread_attr_getstacksize_rt     pthread_attr_getstacksize</span>
00906 <span class="preprocessor"></span>
00907 <span class="comment">/*</span>
00908 <span class="comment"> * WORKING FUNCTIONS USABLE IN HARD REAL TIME, THIS IS THE REAL STUFF</span>
00909 <span class="comment"> */</span>
00910 
00911 <span class="preprocessor">#define pthread_setcancelstate_rt  pthread_setcancelstate</span>
00912 <span class="preprocessor"></span><span class="preprocessor">#define pthread_setcanceltype_rt   pthread_setcanceltype</span>
00913 <span class="preprocessor"></span>
00914 RTAI_PROTO(<span class="keywordtype">void</span>, pthread_testcancel_rt,(<span class="keywordtype">void</span>))
00915 {
00916         <span class="keywordtype">int</span> oldtype, oldstate;
00917         pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;oldstate);
00918         pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &amp;oldtype);
00919         <span class="keywordflow">if</span> (oldstate != PTHREAD_CANCEL_DISABLE &amp;&amp; oldtype != PTHREAD_CANCEL_DEFERRED) {
00920                 MAKE_SOFT();
00921                 rt_task_delete(rt_buddy());
00922                 pthread_exit(NULL);
00923         }
00924         pthread_setcanceltype(oldtype, &amp;oldtype);
00925         pthread_setcancelstate(oldstate, &amp;oldstate);
00926 }
00927 
00928 <span class="keyword">extern</span> <span class="keywordtype">int</span> pthread_yield (<span class="keywordtype">void</span>);
00929 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_yield_rt,(<span class="keywordtype">void</span>))
00930 {
00931         <span class="keywordflow">if</span> (rt_is_hard_real_time(rt_buddy())) {
00932                 <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00933                 rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg);
00934                 <span class="keywordflow">return</span> 0;
00935         }
00936         <span class="keywordflow">return</span> pthread_yield();
00937 }
00938 
00939 RTAI_PROTO(<span class="keywordtype">void</span>, pthread_exit_rt,(<span class="keywordtype">void</span> *retval))
00940 {
00941         MAKE_SOFT();
00942         rt_task_delete(rt_buddy());
00943         pthread_exit(retval);
00944 }
00945 
00946 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_join_rt,(pthread_t thread, <span class="keywordtype">void</span> **thread_return))
00947 {
00948         <span class="keywordtype">int</span> hs, ret;
00949         hs = MAKE_SOFT();
00950         ret = pthread_join(thread, thread_return);
00951         MAKE_HARD(hs);
00952         <span class="keywordflow">return</span> ret;
00953 }
00954 
00955 RTAI_PROTO(<span class="keywordtype">int</span>, sem_wait_rt,(sem_t *sem))
00956 {
00957         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00958         rtai_lxrt(BIDX, SIZARG, SEM_WAIT, &amp;arg);
00959         <span class="keywordflow">return</span> 0;
00960 }
00961 
00962 RTAI_PROTO(<span class="keywordtype">int</span>, sem_trywait_rt,(sem_t *sem))
00963 {
00964         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00965         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, SEM_WAIT_IF, &amp;arg).i[LOW] &gt; 0) {
00966                 <span class="keywordflow">return</span> 0;
00967         }
00968         errno = EAGAIN;
00969         <span class="keywordflow">return</span> -1;
00970 }
00971 
00972 RTAI_PROTO(<span class="keywordtype">int</span>, sem_timedwait_rt,(sem_t *sem, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime))
00973 {
00974         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; RTIME until; } arg = { ((<span class="keywordtype">void</span> **)sem)[0], timespec2count(abstime) };
00975         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_WAIT_UNTIL, &amp;arg).i[LOW] &lt; SEM_VALUE_MAX ? 0 : ETIMEDOUT;
00976 }
00977 
00978 RTAI_PROTO(<span class="keywordtype">int</span>, sem_post_rt,(sem_t *sem))
00979 {
00980         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00981         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_SIGNAL, &amp;arg).i[LOW];
00982 }
00983 
00984 RTAI_PROTO(<span class="keywordtype">int</span>, sem_getvalue_rt,(sem_t *sem, <span class="keywordtype">int</span> *sval))
00985 {
00986         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)sem)[0] };
00987         *sval = rtai_lxrt(BIDX, SIZARG, SEM_COUNT, &amp;arg).i[LOW];
00988         <span class="keywordflow">return</span> 0;
00989 }
00990 
00991 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_lock_rt,(pthread_mutex_t *mutex))
00992 {
00993         <span class="keywordflow">return</span> sem_wait_rt((sem_t *)mutex);
00994 }
00995 
00996 <span class="preprocessor">#ifdef __USE_XOPEN2K</span>
00997 <span class="preprocessor"></span>RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_timedlock_rt,(pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime))
00998 {
00999         <span class="keywordflow">return</span> sem_timedwait_rt((sem_t *)mutex, abstime);
01000 }
01001 <span class="preprocessor">#endif</span>
01002 <span class="preprocessor"></span>
01003 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_trylock_rt,(pthread_mutex_t *mutex))
01004 {
01005         <span class="keywordflow">return</span> sem_trywait_rt((sem_t *)mutex);
01006 }
01007 
01008 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_mutex_unlock_rt,(pthread_mutex_t *mutex))
01009 {
01010         <span class="keywordflow">return</span> sem_post_rt((sem_t *)mutex);
01011 }
01012 
01013 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_signal_rt,(pthread_cond_t *cond))
01014 {
01015         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; } arg = { ((<span class="keywordtype">void</span> **)cond)[0] };
01016         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_SIGNAL, &amp;arg).i[LOW];
01017 }
01018 
01019 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_broadcast_rt,(pthread_cond_t *cond))
01020 {
01021         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; } arg = { ((<span class="keywordtype">void</span> **)cond)[0] };
01022         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SEM_BROADCAST, &amp;arg).i[LOW];
01023 }
01024 
01025 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_wait_rt,(pthread_cond_t *cond, pthread_mutex_t *mutex))
01026 {
01027         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; <span class="keywordtype">void</span> *mutex; } arg = { ((<span class="keywordtype">void</span> **)cond)[0], ((<span class="keywordtype">void</span> **)mutex)[0] };
01028         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT, &amp;arg).i[LOW];
01029 }
01030 
01031 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_cond_timedwait_rt,(pthread_cond_t *cond, pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime))
01032 {
01033         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *cond; <span class="keywordtype">void</span> *mutex; RTIME time; } arg = { ((<span class="keywordtype">void</span> **)cond)[0], ((<span class="keywordtype">void</span> **)mutex)[0], timespec2count(abstime) };
01034         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COND_WAIT_UNTIL, &amp;arg).i[LOW] &lt; SEM_TIMOUT ? 0 : -ETIMEDOUT;
01035 }
01036 
01037 <span class="preprocessor">#ifdef __USE_XOPEN2K</span>
01038 <span class="preprocessor"></span>RTAI_PROTO(<span class="keywordtype">int</span>, pthread_barrier_wait_rt,(pthread_barrier_t *barrier))
01039 {
01040         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *sem; } arg = { ((<span class="keywordtype">void</span> **)barrier)[0] };
01041         rtai_lxrt(BIDX, SIZARG, SEM_WAIT_BARRIER, &amp;arg);
01042         <span class="keywordflow">return</span> 0;
01043 }
01044 <span class="preprocessor">#endif</span>
01045 <span class="preprocessor"></span>
01046 <span class="preprocessor">#ifdef __USE_UNIX98</span>
01047 <span class="preprocessor"></span>RTAI_PROTO(pthread_rwlock_t *, pthread_rwlock_open_rt,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
01048 {
01049         <span class="keywordtype">int</span> hs, fd;
01050         pthread_rwlock_t *rwlock;
01051         hs = MAKE_SOFT();
01052         <span class="keywordflow">if</span> ((fd = open(name, O_RDONLY)) &gt; 0) {
01053                 read(fd, &amp;rwlock, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01054                 close(fd); 
01055                 atomic_inc((atomic_t *)(&amp;((<span class="keywordtype">int</span> *)rwlock)[1]));
01056         } <span class="keywordflow">else</span> {
01057                 <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, value, type; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), 1, RES_SEM };
01058                 rwlock = (pthread_rwlock_t *)malloc(<span class="keyword">sizeof</span>(pthread_rwlock_t));
01059                 <span class="keywordflow">if</span> ((((<span class="keywordtype">int</span> *)rwlock)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_RWL_INIT, &amp;arg).i[LOW]) &amp;&amp; (fd = open(name, O_WRONLY | O_CREAT))) {
01060                         write(fd, &amp;rwlock, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01061                         close(fd); 
01062                         ((<span class="keywordtype">int</span> *)rwlock)[1] = 1;
01063                 } <span class="keywordflow">else</span> {
01064                         free(rwlock);
01065                         rwlock = 0;
01066                 }
01067         }
01068         MAKE_HARD(hs);
01069         <span class="keywordflow">return</span> rwlock;
01070 }
01071 <span class="preprocessor">#endif </span><span class="comment">/* __USE_UNIX98 */</span>
01072 
01073 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_init_rt,(pthread_rwlock_t *rwlock, pthread_rwlockattr_t *attr))
01074 {
01075         <span class="keywordtype">int</span> hs;
01076         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { <a class="code" href="group__lxrt.html#ga1">rt_get_name</a>(0) };
01077         hs = MAKE_SOFT();
01078         ((<span class="keywordtype">int</span> *)rwlock)[0] = rtai_lxrt(BIDX, SIZARG, LXRT_RWL_INIT, &amp;arg).i[LOW];
01079         ((<span class="keywordtype">int</span> *)rwlock)[1] = 0;
01080         MAKE_HARD(hs);
01081         <span class="keywordflow">return</span> 0;
01082 }
01083 
01084 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_close_rt,(pthread_rwlock_t *rwlock))
01085 {
01086         <span class="keywordtype">int</span> hs, cnt;
01087         <span class="keywordtype">char</span> name[7];
01088         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01089         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK_IF, &amp;arg).i[LOW] &lt; 0) {
01090                 <span class="keywordflow">return</span> EBUSY;
01091         } <span class="keywordflow">else</span> {
01092                 rtai_lxrt(BIDX, SIZARG, RWL_UNLOCK, &amp;arg);
01093                 <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK_IF, &amp;arg).i[LOW] &lt; 0) {
01094                         <span class="keywordflow">return</span> EBUSY;
01095                 }
01096                 rtai_lxrt(BIDX, SIZARG, RWL_UNLOCK, &amp;arg);
01097         }
01098         cnt = ((<span class="keywordtype">int</span> *)rwlock)[1];
01099         <span class="keywordflow">if</span> (!cnt || (cnt &amp;&amp; atomic_dec_and_test((atomic_t *)&amp;((<span class="keywordtype">int</span> *)rwlock)[1]))) {
01100                 hs = MAKE_SOFT();
01101                 <a class="code" href="rtai__nam2num_8h.html#a1">num2nam</a>(<a class="code" href="group__lxrt.html#ga1">rt_get_name</a>(((<span class="keywordtype">void</span> **)rwlock)[0]), name);
01102                 rtai_lxrt(BIDX, SIZARG, LXRT_RWL_DELETE, &amp;arg);
01103                 <span class="keywordflow">if</span> (cnt) {
01104                         unlink(name);
01105                         free((<span class="keywordtype">void</span> *)rwlock);
01106                 }
01107                 MAKE_HARD(hs);
01108         }
01109         <span class="keywordflow">return</span> 0;
01110 }
01111 
01112 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_destroy_rt,(pthread_rwlock_t *rwlock))
01113 {
01114         <span class="keywordflow">return</span> pthread_rwlock_close_rt(rwlock);
01115 }
01116 
01117 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_rdlock_rt,(pthread_rwlock_t *rwlock))
01118 {
01119         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01120         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK, &amp;arg).i[LOW];
01121 }
01122 
01123 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_tryrdlock_rt,(pthread_rwlock_t *rwlock))
01124 {
01125         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01126         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK_IF, &amp;arg).i[LOW];
01127 }
01128 
01129 <span class="preprocessor">#ifdef __USE_XOPEN2K</span>
01130 <span class="preprocessor"></span>RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_timedrdlock_rt,(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime))
01131 {
01132         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; RTIME time; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0], timespec2count(abstime) };
01133         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_RDLOCK_UNTIL, &amp;arg).i[LOW];
01134 }
01135 <span class="preprocessor">#endif</span>
01136 <span class="preprocessor"></span>
01137 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_wrlock_rt,(pthread_rwlock_t *rwlock))
01138 {
01139         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01140         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK, &amp;arg).i[LOW];
01141 }
01142 
01143 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_trywrlock_rt,(pthread_rwlock_t *rwlock))
01144 {
01145         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01146         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK_IF, &amp;arg).i[LOW];
01147 }
01148 
01149 <span class="preprocessor">#ifdef __USE_XOPEN2K</span>
01150 <span class="preprocessor"></span>RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_timedwrlock_rt,(pthread_rwlock_t *rwlock, <span class="keyword">struct</span> timespec *abstime))
01151 {
01152         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; RTIME time; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0], timespec2count(abstime) };
01153         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_WRLOCK_UNTIL, &amp;arg).i[LOW];
01154 }
01155 <span class="preprocessor">#endif</span>
01156 <span class="preprocessor"></span>
01157 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_rwlock_unlock_rt,(pthread_rwlock_t *rwlock))
01158 {
01159         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *rwlock; } arg = { ((<span class="keywordtype">void</span> **)rwlock)[0] };
01160         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RWL_UNLOCK, &amp;arg).i[LOW];
01161 }
01162 
01163 <span class="preprocessor">#ifdef __USE_XOPEN2K</span>
01164 <span class="preprocessor"></span>RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_init_rt,(pthread_spinlock_t *lock))
01165 {
01166         <span class="keywordflow">return</span> (((<span class="keywordtype">int</span> *)lock)[0] = 0);
01167 }
01168 
01169 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_destroy_rt,(pthread_spinlock_t *lock))
01170 {
01171         <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *)lock)[0] = 0;
01172 }
01173 
01174 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_lock_rt,(pthread_spinlock_t *lock))
01175 {
01176         <span class="keywordflow">while</span> (atomic_cmpxchg(&amp;lock, 0, 1));
01177         <span class="keywordflow">return</span> 0;
01178 }
01179 
01180 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_trylock_rt,(pthread_spinlock_t *lock))
01181 {
01182         <span class="keywordflow">if</span> (atomic_cmpxchg(&amp;lock, 0, 1)) {
01183                 <span class="keywordflow">return</span> EAGAIN;
01184         }
01185         <span class="keywordflow">return</span> 0;
01186 }
01187 
01188 RTAI_PROTO(<span class="keywordtype">int</span>, pthread_spin_unlock_rt,(pthread_spinlock_t *lock))
01189 {
01190         <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *)lock)[0] = 0;
01191 }
01192 <span class="preprocessor">#endif</span>
01193 <span class="preprocessor"></span>
01194 RTAI_PROTO(<span class="keywordtype">void</span>, clock_gettime_rt,(<span class="keywordtype">int</span> clockid, <span class="keyword">struct</span> timespec *current_time))
01195 {
01196         count2timespec(rt_get_time(), current_time);
01197 }
01198 
01199 RTAI_PROTO(<span class="keywordtype">int</span>, nanosleep_rt,(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *rqtp, <span class="keyword">struct</span> timespec *rmtp))
01200 {
01201         RTIME expire;
01202         <span class="keywordflow">if</span> (rqtp-&gt;tv_nsec &gt;= 1000000000L || rqtp-&gt;tv_nsec &lt; 0 || rqtp-&gt;tv_sec &lt; 0) {
01203                 <span class="keywordflow">return</span> -EINVAL;
01204         }
01205         <a class="code" href="api_8c.html#a33">rt_sleep_until</a>(expire = rt_get_time() + timespec2count(rqtp));
01206         <span class="keywordflow">if</span> ((expire -= rt_get_time()) &gt; 0) {
01207                 <span class="keywordflow">if</span> (rmtp) {
01208                         count2timespec(expire, rmtp);
01209                 }
01210                 <span class="keywordflow">return</span> -EINTR;
01211         }
01212         <span class="keywordflow">return</span> 0;
01213 }
01214 
01215 <span class="preprocessor">#ifdef __cplusplus</span>
01216 <span class="preprocessor"></span>}
01217 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01218 
01219 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ */</span>
01220 
01221 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_POSIX_H_ */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:52 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
