<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_lxrt.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a></div>
<h1>rtai_lxrt.h</h1><a href="rtai__lxrt_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00066 <span class="preprocessor">#ifndef _RTAI_LXRT_H</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_LXRT_H</span>
00068 <span class="preprocessor"></span>
00069 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00070 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00071 
00072 <span class="comment">// scheduler</span>
00073 <span class="preprocessor">#define YIELD                            0</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND                          1</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define RESUME                           2</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC                    3</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define WAIT_PERIOD                      4</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP                            5</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP_UNTIL                      6</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define START_TIMER                      7</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define STOP_TIMER                       8</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME                         9</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO                      10</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT                      11</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define BUSY_SLEEP                      12</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIODIC_MODE               13</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define SET_ONESHOT_MODE                14</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define SIGNAL_HANDLER                  15</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define TASK_USE_FPU                    16</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define LINUX_USE_FPU                   17</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_GEN              18</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS                     19</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define GET_CPU_TIME_NS                 20</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUS            21 </span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUID           22       </span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMER_CPU                   23       </span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define START_RT_APIC_TIMERS            24</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_CPUID            25</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO_CPUID                26</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT_CPUID                27</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_CPUID                  28</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS_CPUID               29</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC_NS                30</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#define SET_SCHED_POLICY                31</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_END                  32</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define SPV_RMS                         33</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define WAKEUP_SLEEPING                 34</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_TASK_PRIO                35</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_TIME                 36</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIOD                      37</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#define HARD_TIMER_RUNNING              38</span>
00112 <span class="preprocessor"></span>
00113 <span class="comment">// semaphores</span>
00114 <span class="preprocessor">#define TYPED_SEM_INIT                  39</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define SEM_DELETE                      40</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_INIT                  41</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_DELETE                42</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#define SEM_SIGNAL                      43</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT                        44</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_IF                     45</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_UNTIL                  46</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_TIMED                  47</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BROADCAST                   48</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_BARRIER                49</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define SEM_COUNT                       50</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT                       51</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_UNTIL                 52</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_TIMED                 53</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define RWL_INIT                        54</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#define RWL_DELETE                      55</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_INIT                  56</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_DELETE                57</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK                      58</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_IF                   59</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_UNTIL                60</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_TIMED                61</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK                      62      </span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_IF                   63</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_UNTIL                64</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_TIMED                65</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define RWL_UNLOCK                      66</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define SPL_INIT                        67</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#define SPL_DELETE                      68</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_INIT                  69</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_DELETE                70</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK                        71      </span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_IF                     72</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_TIMED                  73</span>
00149 <span class="preprocessor"></span><span class="preprocessor">#define SPL_UNLOCK                      74</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">// mail boxes</span>
00152 <span class="preprocessor">#define TYPED_MBX_INIT                  75</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define MBX_DELETE                      76</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_INIT                  77</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_DELETE                78</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND                        79</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_WP                     80</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_IF                     81</span>
00159 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_UNTIL                  82</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_TIMED                  83</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE                     84</span>
00162 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_WP                  85</span>
00163 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_IF                  86</span>
00164 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_UNTIL               87</span>
00165 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_TIMED               88</span>
00166 <span class="preprocessor"></span><span class="preprocessor">#define MBX_EVDRP                       89</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define MBX_OVRWR_SEND                  90</span>
00168 <span class="preprocessor"></span>
00169 <span class="comment">// short intertask messages</span>
00170 <span class="preprocessor">#define SENDMSG                         91</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#define SEND_IF                         92</span>
00172 <span class="preprocessor"></span><span class="preprocessor">#define SEND_UNTIL                      93</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#define SEND_TIMED                      94</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEMSG                      95</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_IF                      96</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_UNTIL                   97</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_TIMED                   98</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#define RPCMSG                          99</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define RPC_IF                         100</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define RPC_UNTIL                      101</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#define RPC_TIMED                      102</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#define EVDRP                          103</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#define ISRPC                          104</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#define RETURNMSG                      105</span>
00185 <span class="preprocessor"></span>
00186 <span class="comment">// extended intertask messages</span>
00187 <span class="preprocessor">#define RPCX                           106</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_IF                        107</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_UNTIL                     108</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_TIMED                     109</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#define SENDX                          110</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_IF                       111</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_UNTIL                    112</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_TIMED                    113</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#define RETURNX                        114</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX                       115</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_IF                    116</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_UNTIL                 117</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_TIMED                 118</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define EVDRPX                         119</span>
00201 <span class="preprocessor"></span>
00202 <span class="comment">// proxies</span>
00203 <span class="preprocessor">#define PROXY_ATTACH                   120</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_DETACH                   121</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_TRIGGER                  122</span>
00206 <span class="preprocessor"></span>
00207 
00208 <span class="comment">// synchronous user space specific intertask messages and related proxies</span>
00209 <span class="preprocessor">#define RT_SEND                        123</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define RT_RECEIVE                     124</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define RT_CRECEIVE                    125</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define RT_REPLY                       126</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_ATTACH                127</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_DETACH                128</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define RT_TRIGGER                     129</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_ATTACH                 130</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_DETACH                 131</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_LOCATE                 132</span>
00219 <span class="preprocessor"></span>
00220 <span class="comment">// bits</span>
00221 <span class="preprocessor">#define BITS_INIT                      133      </span>
00222 <span class="preprocessor"></span><span class="preprocessor">#define BITS_DELETE                    134</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_INIT                135</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_DELETE              136</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#define BITS_GET                       137</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define BITS_RESET                     138</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#define BITS_SIGNAL                    139</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT                      140</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_IF                   141              </span>
00230 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_UNTIL                142</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_TIMED                143</span>
00232 <span class="preprocessor"></span>
00233 <span class="comment">// typed mail boxes</span>
00234 <span class="preprocessor">#define TBX_INIT                       144</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#define TBX_DELETE                     145</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_INIT                 146</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_DELETE               147</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND                       148</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_IF                    149</span>
00240 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_UNTIL                 150</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_TIMED                 151</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE                    152</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_IF                 153</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_UNTIL              154</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_TIMED              155</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST                  156</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_IF               157</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_UNTIL            158</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_TIMED            159</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT                     160</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_IF                  161</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_UNTIL               162</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_TIMED               163</span>
00254 <span class="preprocessor"></span>
00255 <span class="comment">// pqueue</span>
00256 <span class="preprocessor">#define MQ_OPEN                        164</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#define MQ_RECEIVE                     165</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SEND                        166</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#define MQ_CLOSE                       167</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#define MQ_GETATTR                     168</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SETATTR                     169</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define MQ_NOTIFY                      170</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#define MQ_UNLINK                      171</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDRECEIVE                172</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDSEND                   173</span>
00266 <span class="preprocessor"></span>
00267 <span class="comment">// named tasks init/delete</span>
00268 <span class="preprocessor">#define NAMED_TASK_INIT                174</span>
00269 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_INIT_CPUID          175</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_DELETE              176</span>
00271 <span class="preprocessor"></span>
00272 <span class="comment">// registry</span>
00273 <span class="preprocessor">#define GET_ADR                        177</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#define GET_NAME                       178</span>
00275 <span class="preprocessor"></span>
00276 <span class="comment">// netrpc</span>
00277 <span class="preprocessor">#define NETRPC                         179</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#define SEND_REQ_REL_PORT              180</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#define DDN2NL                         181</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#define SET_THIS_NODE                  182</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#define FIND_ASGN_STUB                 183</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#define REL_STUB                       184      </span>
00283 <span class="preprocessor"></span><span class="preprocessor">#define WAITING_RETURN                 185</span>
00284 <span class="preprocessor"></span>
00285 <span class="comment">// a semaphore extension</span>
00286 <span class="preprocessor">#define COND_SIGNAL                    186</span>
00287 <span class="preprocessor"></span>
00288 <span class="comment">// new shm</span>
00289 <span class="preprocessor">#define SHM_ALLOC                      187</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#define SHM_FREE                       188</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define SHM_SIZE                       189</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_SET                       190</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_ALLOC                     191</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_FREE                      192</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_ALLOC               193</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_FREE                194</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define MALLOC                         195</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#define FREE                           196</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MALLOC                   197</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_FREE                     198</span>
00301 <span class="preprocessor"></span>
00302 <span class="preprocessor">#define SUSPEND_IF                     199</span>
00303 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND_UNTIL                  200</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND_TIMED                  201</span>
00305 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT                       202      </span>
00306 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT_IF                    203      </span>
00307 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT_UNTIL                 204</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT_TIMED                 205</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_SIGNAL                     206</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define REQUEST_IRQ_TASK               207</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define RELEASE_IRQ_TASK               208</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#define SCHED_LOCK                     209</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define SCHED_UNLOCK                   210</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#define PEND_LINUX_IRQ                 211</span>
00315 <span class="preprocessor"></span>
00316 <span class="preprocessor">#define MAX_LXRT_FUN                   213</span>
00317 <span class="preprocessor"></span>
00318 <span class="comment">// not recovered yet </span>
00319 <span class="comment">// Qblk's </span>
00320 <span class="preprocessor">#define RT_INITTICKQUEUE                69</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#define RT_RELEASETICKQUEUE             70</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNALLOC                    71</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNFREE                     72</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNINIT                     73</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKWAIT                     74</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKREPEAT                   75</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSOON                     76</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKDEQUEUE                  77</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCANCEL                   78</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSYNC                        79</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define RT_QRECEIVE                     80</span>
00332 <span class="preprocessor"></span><span class="preprocessor">#define RT_QLOOP                        81</span>
00333 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSTEP                        82</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKBEFORE                   83</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKAFTER                    84</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKUNHOOK                   85</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKRELEASE                  86</span>
00338 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCOMPLETE                 87</span>
00339 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKFLUSH                   88</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATHEAD                   89</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATTAIL                   90</span>
00342 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKINIT                    91</span>
00343 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKRELEASE                 92</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSCHEDULE                 93</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define RT_GETTICKQUEUEHOOK             94</span>
00346 <span class="preprocessor"></span><span class="comment">// Testing</span>
00347 <span class="preprocessor">#define RT_BOOM                         95</span>
00348 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_MALLOC                     96</span>
00349 <span class="preprocessor"></span><span class="preprocessor">#define RT_FREE                         97</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define RT_MMGR_STATS                   98</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define RT_STOMP                        99</span>
00352 <span class="preprocessor"></span><span class="comment">// VC</span>
00353 <span class="preprocessor">#define RT_VC_ATTACH                    100</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RELEASE                   101</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RESERVE                   102</span>
00356 <span class="preprocessor"></span><span class="comment">// Linux Signal Support</span>
00357 <span class="preprocessor">#define RT_GET_LINUX_SIGNAL             103</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#define RT_GET_ERRNO                    104</span>
00359 <span class="preprocessor"></span><span class="preprocessor">#define RT_SET_LINUX_SIGNAL_HANDLER     105</span>
00360 <span class="preprocessor"></span><span class="comment">// end of not recovered yet</span>
00361 
00362 <span class="preprocessor">#define LXRT_GET_ADR            1000</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_GET_NAME           1001</span>
00364 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_INIT          1002</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_DELETE        1003</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_INIT           1004</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_DELETE         1005</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_INIT           1006</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_DELETE         1007</span>
00370 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_SOFT_RT            1008</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_HARD_RT            1009</span>
00372 <span class="preprocessor"></span><span class="preprocessor">#define PRINT_TO_SCREEN         1010</span>
00373 <span class="preprocessor"></span><span class="preprocessor">#define NONROOT_HRT             1011</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define RT_BUDDY                1012</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define HRT_USE_FPU             1013</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#define USP_SIGHDL              1014</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLAGS           1015</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLAGS           1016</span>
00379 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLG_MSK         1017</span>
00380 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLG_MSK         1018</span>
00381 <span class="preprocessor"></span><span class="preprocessor">#define IS_HARD                 1019</span>
00382 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_FORK               1020</span>
00383 <span class="preprocessor"></span><span class="preprocessor">#define ALLOC_REGISTER          1021</span>
00384 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_DEREGISTER       1022</span>
00385 <span class="preprocessor"></span><span class="preprocessor">#define FORCE_TASK_SOFT         1023</span>
00386 <span class="preprocessor"></span><span class="preprocessor">#define PRINTK                  1024</span>
00387 <span class="preprocessor"></span><span class="preprocessor">#define GET_EXECTIME            1025</span>
00388 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMEORIG            1026</span>
00389 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_INIT           1027</span>
00390 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_DELETE         1028</span>
00391 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_INIT           1029</span>
00392 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_DELETE         1030</span>
00393 <span class="preprocessor"></span>
00394 <span class="preprocessor">#define FORCE_SOFT 0x80000000</span>
00395 <span class="preprocessor"></span>
00396 <span class="comment">// Keep LXRT call enc/decoding together, so you are sure to act consistently.</span>
00397 <span class="comment">// This is the encoding, note " | GT_NR_SYSCALLS" to ensure not a Linux syscall, ...</span>
00398 <span class="preprocessor">#define GT_NR_SYSCALLS  (1 &lt;&lt; 15)</span>
00399 <span class="preprocessor"></span><span class="preprocessor">#define ENCODE_LXRT_REQ(dynx, srq, lsize)  (((dynx) &lt;&lt; 28) | (((srq) &amp; 0xFFF) &lt;&lt; 16) | GT_NR_SYSCALLS | (lsize))</span>
00400 <span class="preprocessor"></span><span class="comment">// ... and this is the decoding.</span>
00401 <span class="preprocessor">#define SRQ(x)   (((x) &gt;&gt; 16) &amp; 0xFFF)</span>
00402 <span class="preprocessor"></span><span class="preprocessor">#define NARG(x)  ((x) &amp; (GT_NR_SYSCALLS - 1))</span>
00403 <span class="preprocessor"></span><span class="preprocessor">#define INDX(x)  (((x) &gt;&gt; 28) &amp; 0xF)</span>
00404 <span class="preprocessor"></span>
00405 <span class="preprocessor">#ifdef __KERNEL__</span>
00406 <span class="preprocessor"></span>
00407 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00408 
00409 <span class="comment">/*</span>
00410 <span class="comment">     Encoding of system call argument</span>
00411 <span class="comment">            31                                    0  </span>
00412 <span class="comment">soft SRQ    .... |||| |||| |||| .... .... .... ....  0 - 4095 max</span>
00413 <span class="comment">int  NARG   .... .... .... .... |||| |||| |||| ||||  </span>
00414 <span class="comment">arg  INDX   |||| .... .... .... .... .... .... ....</span>
00415 <span class="comment">*/</span>
00416 
00417 <span class="comment">/*</span>
00418 <span class="comment">These USP (unsigned long long) type fields allow to read and write up to 2 arguments.  </span>
00419 <span class="comment">                                               </span>
00420 <span class="comment">RW marker .... .... .... .... .... .... .... ..|| .... .... .... .... .... .... .... ...|</span>
00421 <span class="comment"></span>
00422 <span class="comment">HIGH unsigned long encodes writes</span>
00423 <span class="comment">W ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00424 <span class="comment">W ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00425 <span class="comment">W ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00426 <span class="comment">W ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00427 <span class="comment">W 1st  LL .|.. .... .... .... .... .... .... ....</span>
00428 <span class="comment">W 2nd  LL |... .... .... .... .... .... .... ....</span>
00429 <span class="comment"></span>
00430 <span class="comment">LOW unsigned long encodes reads</span>
00431 <span class="comment">R ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00432 <span class="comment">R ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00433 <span class="comment">R ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00434 <span class="comment">R ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00435 <span class="comment">R 1st  LL .|.. .... .... .... .... .... .... ....</span>
00436 <span class="comment">R 2nd  LL |... .... .... .... .... .... .... ....</span>
00437 <span class="comment"></span>
00438 <span class="comment">LOW unsigned long encodes also</span>
00439 <span class="comment">RT Switch .... .... .... .... .... .... .... ...|</span>
00440 <span class="comment"></span>
00441 <span class="comment">and </span>
00442 <span class="comment">Always 0  .... .... .... .... .... .... .... ..|.</span>
00443 <span class="comment"></span>
00444 <span class="comment">If SZ is zero sizeof(int) is copied by default, if LL bit is set sizeof(long long) is copied.</span>
00445 <span class="comment">*/</span>
00446 
00447 <span class="comment">// These are for setting appropriate bits in any function entry structure, OR</span>
00448 <span class="comment">// them in fun entry type to obtain the desired encoding</span>
00449 
00450 <span class="comment">// for writes</span>
00451 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00452 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00453 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00454 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00455 <span class="preprocessor"></span>
00456 <span class="comment">// for reads</span>
00457 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00458 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00459 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00460 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00461 <span class="preprocessor"></span>
00462 <span class="comment">// and these are for deciding what to do in lxrt.c</span>
00463 <span class="preprocessor">#define NEED_TO_RW(x)   (((unsigned long *)&amp;(x))[HIGH])</span>
00464 <span class="preprocessor"></span>
00465 <span class="preprocessor">#define NEED_TO_R(x)    (((unsigned long *)&amp;(x))[LOW]  &amp; 0x0000FFFC)</span>
00466 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W(x)    (((unsigned long *)&amp;(x))[HIGH] &amp; 0x0000FFFC)</span>
00467 <span class="preprocessor"></span>
00468 <span class="preprocessor">#define NEED_TO_R2ND(x) (((unsigned long *)&amp;(x))[LOW]  &amp; 0x3FFF0000)</span>
00469 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W2ND(x) (((unsigned long *)&amp;(x))[HIGH] &amp; 0x3FFF0000)</span>
00470 <span class="preprocessor"></span>
00471 <span class="preprocessor">#define USP_RBF1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  2) &amp; 0x7F)</span>
00472 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  9) &amp; 0x7F)</span>
00473 <span class="preprocessor"></span><span class="preprocessor">#define USP_RBF2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 16) &amp; 0x7F)</span>
00474 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 23) &amp; 0x7F)</span>
00475 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x40000000)</span>
00476 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x80000000)</span>
00477 <span class="preprocessor"></span>
00478 <span class="preprocessor">#define USP_WBF1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  2) &amp; 0x7F)</span>
00479 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  9) &amp; 0x7F)</span>
00480 <span class="preprocessor"></span><span class="preprocessor">#define USP_WBF2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 16) &amp; 0x7F)</span>
00481 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 23) &amp; 0x7F)</span>
00482 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x40000000)</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x80000000)</span>
00484 <span class="preprocessor"></span>
00485 <span class="keyword">struct </span>rt_fun_entry {
00486     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> type;
00487     <span class="keywordtype">void</span> *fun;
00488 };
00489 
00490 <span class="keyword">struct </span>rt_native_fun_entry {
00491     <span class="keyword">struct </span>rt_fun_entry fun;
00492     <span class="keywordtype">int</span> index;
00493 };
00494 
00495 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_fun_entry rt_fun_lxrt[];
00496 
00497 <span class="keywordtype">void</span> reset_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00498 
00499 <span class="keywordtype">int</span> set_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00500 
00501 <span class="preprocessor">#ifdef __cplusplus</span>
00502 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00503 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00504 
00505 <span class="preprocessor">#if CONFIG_RTAI_INTERNAL_LXRT_SUPPORT</span>
00506 <span class="preprocessor"></span> 
00507 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00508 {
00509         <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> long)pid) &gt; PID_MAX_LIMIT ? (<span class="keyword">struct </span>rt_task_struct *)pid : find_task_by_pid(pid)-&gt;rtai_tskext[0];
00510 }
00511 
00512 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00513 {
00514     <span class="keywordflow">return</span> task-&gt;lnxtsk ? task-&gt;lnxtsk-&gt;pid : (int) task;
00515 }
00516 
00517 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00518 
00519 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00520 {
00521     <span class="keywordflow">return</span> 0;
00522 }
00523 
00524 <span class="comment">// The following might look strange but it must be so to work with</span>
00525 <span class="comment">// buddies also.</span>
00526 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00527 {
00528     <span class="keywordflow">return</span> (int) task;
00529 }
00530 
00531 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00532 
00533 <span class="keywordtype">int</span> set_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00534 
00535 <span class="keywordtype">void</span> remove_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00536 
00537 RT_TASK *rt_lxrt_whoami(<span class="keywordtype">void</span>);
00538 
00539 <span class="keywordtype">void</span> exec_func(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn),
00540                <span class="keywordtype">void</span> *data,
00541                <span class="keywordtype">int</span> evn);
00542 
00543 <span class="keywordtype">int</span>  set_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00544                           <span class="keywordtype">int</span> idx);
00545 
00546 <span class="keywordtype">void</span> reset_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00547                             <span class="keywordtype">int</span> idx);
00548 
00549 <span class="preprocessor">#ifdef __cplusplus</span>
00550 <span class="preprocessor"></span>}
00551 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00552 
00553 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00554 
00555 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00556 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00557 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00558 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00559 <span class="preprocessor">#include &lt;string.h&gt;</span>
00560 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00561 
00562 <span class="keyword">struct </span>apic_timer_setup_data;
00563 
00564 <span class="preprocessor">#define rt_grow_and_lock_stack(incr) \</span>
00565 <span class="preprocessor">        do { \</span>
00566 <span class="preprocessor">                char buf[incr]; \</span>
00567 <span class="preprocessor">                memset(buf, 0, incr); \</span>
00568 <span class="preprocessor">                mlockall(MCL_CURRENT | MCL_FUTURE); \</span>
00569 <span class="preprocessor">        } while (0)</span>
00570 <span class="preprocessor"></span>
00571 <span class="preprocessor">#define BIDX   0 // rt_fun_ext[0]</span>
00572 <span class="preprocessor"></span><span class="preprocessor">#define SIZARG sizeof(arg)</span>
00573 <span class="preprocessor"></span>
00574 <span class="preprocessor">#ifdef __cplusplus</span>
00575 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00576 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00577 
<a name="l00585"></a><a class="code" href="group__lxrt.html#ga0">00585</a> RTAI_PROTO(<span class="keywordtype">void</span> *,rt_get_adr,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name))
00586 {
00587         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { name };
00588         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_ADR, &amp;arg).v[LOW];
00589 } 
00590 
<a name="l00599"></a><a class="code" href="group__lxrt.html#ga1">00599</a> RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_name,(<span class="keywordtype">void</span> *adr))
00600 {
00601         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *adr; } arg = { adr };
00602         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_NAME, &amp;arg).i[LOW];
00603 }
00604 
00605 RTAI_PROTO(RT_TASK *,rt_task_init_schmod,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00606 {
00607         <span class="keyword">struct </span>sched_param mysched;
00608         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, cpus_allowed };
00609 
00610         mysched.sched_priority = sched_get_priority_max(policy) - priority;
00611         <span class="keywordflow">if</span> (mysched.sched_priority &lt; 1 ) {
00612                 mysched.sched_priority = 1;
00613         }
00614         <span class="keywordflow">if</span> (sched_setscheduler(0, policy, &amp;mysched) &lt; 0) {
00615                 <span class="keywordflow">return</span> 0;
00616         }
00617 
00618         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00619 }
00620 
00621 <span class="preprocessor">#define RT_THREAD_STACK_MIN 64*1024</span>
00622 <span class="preprocessor"></span>
00623 <span class="preprocessor">#if 1</span>
00624 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pthread.h&gt;</span>
00625 
00626 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_create,(<span class="keywordtype">void</span> *fun, <span class="keywordtype">void</span> *args, <span class="keywordtype">int</span> stack_size))
00627 {
00628         pthread_t thread;
00629         pthread_attr_t attr;
00630         pthread_attr_init(&amp;attr);
00631         <span class="keywordflow">if</span> (pthread_attr_setstacksize(&amp;attr, stack_size &gt; RT_THREAD_STACK_MIN ? stack_size : RT_THREAD_STACK_MIN)) {
00632                 <span class="keywordflow">return</span> -1;
00633         }
00634         <span class="keywordflow">if</span> (pthread_create(&amp;thread, &amp;attr, (<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))fun, args)) {
00635                 <span class="keywordflow">return</span> -1;
00636         }
00637         <span class="keywordflow">return</span> thread;
00638 }
00639 
00640 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_join, (<span class="keywordtype">int</span> thread))
00641 {
00642         <span class="keywordflow">return</span> pthread_join((pthread_t)thread, NULL);
00643 }
00644 
00645 <span class="preprocessor">#else</span>
00646 <span class="preprocessor"></span>
00647 <span class="preprocessor">#include &lt;sys/wait.h&gt;</span>
00648 
00649 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_create, (<span class="keywordtype">void</span> *fun, <span class="keywordtype">void</span> *args, <span class="keywordtype">int</span> stack_size))
00650 {
00651         <span class="keywordtype">void</span> *sp;
00652         <span class="keywordflow">if</span> (stack_size &lt; RT_THREAD_STACK_MIN) {
00653                 stack_size = RT_THREAD_STACK_MIN;
00654         }
00655         memset(sp = malloc(stack_size), 0, stack_size);
00656         sp = (<span class="keywordtype">void</span> *)(((<span class="keywordtype">unsigned</span> long)sp + stack_size - 16) &amp; ~0xF);
00657         <span class="keywordflow">return</span> clone(fun, sp, CLONE_VM | CLONE_FS | CLONE_FILES, args);
00658 }
00659 
00660 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_join, (<span class="keywordtype">int</span> thread))
00661 {
00662         <span class="keywordflow">return</span> waitpid(thread, NULL, 0);
00663 }
00664 
00665 <span class="preprocessor">#endif</span>
00666 <span class="preprocessor"></span>
00667 RTAI_PROTO(RT_TASK *, rt_thread_init, (<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00668 {
00669         <span class="keywordflow">return</span> rt_task_init_schmod(name, priority, 0, max_msg_size, policy, cpus_allowed);
00670 }
00671 
<a name="l00725"></a><a class="code" href="group__lxrt.html#ga6">00725</a> RTAI_PROTO(RT_TASK *,rt_task_init,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size))
00726 {
00727         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, 0xFF };
00728         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00729 }
00730 
00731 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_sched_policy,(RT_TASK *task, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> rr_quantum_ns))
00732 {
00733         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> policy; <span class="keywordtype">int</span> rr_quantum_ns; } arg = { task, policy, rr_quantum_ns };
00734         rtai_lxrt(BIDX, SIZARG, SET_SCHED_POLICY, &amp;arg);
00735 }
00736 
00737 RTAI_PROTO(<span class="keywordtype">int</span>,rt_change_prio,(RT_TASK *task, <span class="keywordtype">int</span> priority))
00738 {
00739         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> priority; } arg = { task, priority };
00740         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, CHANGE_TASK_PRIO, &amp;arg).i[LOW];
00741 }
00742 
<a name="l00755"></a><a class="code" href="group__lxrt.html#ga9">00755</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_soft_real_time,(<span class="keywordtype">void</span>))
00756 {
00757         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00758         rtai_lxrt(BIDX, SIZARG, MAKE_SOFT_RT, &amp;arg);
00759 }
00760 
00761 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_delete,(RT_TASK *task))
00762 {
00763         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00764         <a class="code" href="group__lxrt.html#ga9">rt_make_soft_real_time</a>();
00765         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_TASK_DELETE, &amp;arg).i[LOW];
00766 }
00767 
00768 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_yield,(<span class="keywordtype">void</span>))
00769 {
00770         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00771         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg).i[LOW];
00772 }
00773 
00774 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend,(RT_TASK *task))
00775 {
00776         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00777         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND, &amp;arg).i[LOW];
00778 }
00779 
00780 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend_if,(RT_TASK *task))
00781 {
00782         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00783         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND_IF, &amp;arg).i[LOW];
00784 }
00785 
00786 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend_until,(RT_TASK *task, RTIME time))
00787 {
00788         <span class="keyword">struct </span>{ RT_TASK *task; RTIME time; } arg = { task, time };
00789         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND_UNTIL, &amp;arg).i[LOW];
00790 }
00791 
00792 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend_timed,(RT_TASK *task, RTIME delay))
00793 {
00794         <span class="keyword">struct </span>{ RT_TASK *task; RTIME delay; } arg = { task, delay };
00795         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND_TIMED, &amp;arg).i[LOW];
00796 }
00797 
00798 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_resume,(RT_TASK *task))
00799 {
00800         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00801         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RESUME, &amp;arg).i[LOW];
00802 }
00803 
00804 RTAI_PROTO(<span class="keywordtype">void</span>, rt_sched_lock, (<span class="keywordtype">void</span>))
00805 {
00806         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg;
00807         rtai_lxrt(BIDX, SIZARG, SCHED_LOCK, &amp;arg);
00808 }
00809 
00810 RTAI_PROTO(<span class="keywordtype">void</span>, rt_sched_unlock, (<span class="keywordtype">void</span>))
00811 {
00812         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg;
00813         rtai_lxrt(BIDX, SIZARG, SCHED_UNLOCK, &amp;arg);
00814 }
00815 
00816 RTAI_PROTO(<span class="keywordtype">void</span>, rt_pend_linux_irq, (<span class="keywordtype">unsigned</span> irq))
00817 {
00818         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00819         rtai_lxrt(BIDX, SIZARG, PEND_LINUX_IRQ, &amp;arg);
00820 }
00821 
00822 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait, (<span class="keywordtype">unsigned</span> irq))
00823 {
00824         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00825         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT, &amp;arg).i[LOW];
00826 }
00827 
00828 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait_if, (<span class="keywordtype">unsigned</span> irq))
00829 {
00830         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00831         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT_IF, &amp;arg).i[LOW];
00832 }
00833 
00834 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait_until, (<span class="keywordtype">unsigned</span> irq, RTIME time))
00835 {
00836         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; RTIME time; } arg = { irq, time };
00837         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT_UNTIL, &amp;arg).i[LOW];
00838 }
00839 
00840 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait_timed, (<span class="keywordtype">unsigned</span> irq, RTIME delay))
00841 {
00842         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; RTIME delay; } arg = { irq, delay };
00843         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT_TIMED, &amp;arg).i[LOW];
00844 }
00845 
00846 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_signal, (<span class="keywordtype">unsigned</span> irq))
00847 {
00848         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00849         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_SIGNAL, &amp;arg).i[LOW];
00850 }
00851 
00852 RTAI_PROTO(<span class="keywordtype">int</span>, rt_request_irq_task, (<span class="keywordtype">unsigned</span> irq, <span class="keywordtype">void</span> *handler, <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> affine2task))
00853 {
00854         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; <span class="keywordtype">void</span> *handler; <span class="keywordtype">int</span> type, affine2task; } arg = { irq, handler, type, affine2task };
00855         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, REQUEST_IRQ_TASK, &amp;arg).i[LOW];
00856 }
00857 
00858 
00859 RTAI_PROTO(<span class="keywordtype">int</span>, rt_release_irq_task, (<span class="keywordtype">unsigned</span> irq))
00860 {
00861         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00862         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RELEASE_IRQ_TASK, &amp;arg).i[LOW];
00863 }
00864 
00865 RTAI_PROTO(<span class="keywordtype">int</span>, rt_task_make_periodic,(RT_TASK *task, RTIME start_time, RTIME period))
00866 {
00867         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_time, period };
00868         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC, &amp;arg).i[LOW];
00869 }
00870 
00871 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_make_periodic_relative_ns,(RT_TASK *task, RTIME start_delay, RTIME period))
00872 {
00873         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_delay, period };
00874         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC_NS, &amp;arg).i[LOW];
00875 }
00876 
00877 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_wait_period,(<span class="keywordtype">void</span>))
00878 {
00879         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00880         rtai_lxrt(BIDX, SIZARG, WAIT_PERIOD, &amp;arg);
00881 }
00882 
00883 RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep,(RTIME delay))
00884 {
00885         <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00886         rtai_lxrt(BIDX, SIZARG, SLEEP, &amp;arg);
00887 }
00888 
00889 RTAI_PROTO(<span class="keywordtype">void</span>,rt_sleep_until,(RTIME time))
00890 {
00891         <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00892         rtai_lxrt(BIDX, SIZARG, SLEEP_UNTIL, &amp;arg);
00893 }
00894 
00895 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_timer_running,(<span class="keywordtype">void</span>))
00896 {
00897         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00898         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, HARD_TIMER_RUNNING, &amp;arg).i[LOW];
00899 }
00900 
00901 RTAI_PROTO(RTIME, start_rt_timer,(<span class="keywordtype">int</span> period))
00902 {
00903         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> period; } arg = { period };
00904         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, START_TIMER, &amp;arg).rt;
00905 }
00906 
00907 RTAI_PROTO(<span class="keywordtype">void</span>, stop_rt_timer,(<span class="keywordtype">void</span>))
00908 {
00909         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00910         rtai_lxrt(BIDX, SIZARG, STOP_TIMER, &amp;arg);
00911 }
00912 
00913 RTAI_PROTO(RTIME,rt_get_time,(<span class="keywordtype">void</span>))
00914 {
00915         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00916         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME, &amp;arg).rt;
00917 }
00918 
00919 RTAI_PROTO(RTIME,count2nano,(RTIME count))
00920 {
00921         <span class="keyword">struct </span>{ RTIME count; } arg = { count };
00922         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO, &amp;arg).rt;
00923 }
00924 
00925 RTAI_PROTO(RTIME,nano2count,(RTIME nanos))
00926 {
00927         <span class="keyword">struct </span>{ RTIME nanos; } arg = { nanos };
00928         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT, &amp;arg).rt;
00929 }
00930 
00931 RTAI_PROTO(<span class="keywordtype">void</span>,rt_busy_sleep,(<span class="keywordtype">int</span> ns))
00932 {
00933         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> ns; } arg = { ns };
00934         rtai_lxrt(BIDX, SIZARG, BUSY_SLEEP, &amp;arg);
00935 }
00936 
00937 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_periodic_mode,(<span class="keywordtype">void</span>))
00938 {
00939         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00940         rtai_lxrt(BIDX, SIZARG, SET_PERIODIC_MODE, &amp;arg);
00941 }
00942 
00943 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_oneshot_mode,(<span class="keywordtype">void</span>))
00944 {
00945         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00946         rtai_lxrt(BIDX, SIZARG, SET_ONESHOT_MODE, &amp;arg);
00947 }
00948 
00949 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
00950 {
00951         <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(void); } arg = { task, handler };
00952         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SIGNAL_HANDLER, &amp;arg).i[LOW];
00953 }
00954 
00955 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00956 {
00957         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00958         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW] != task) {
00959                 <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00960         } <span class="keywordflow">else</span> {
00961 <span class="comment">// note that it would be enough to do whatever FP op here to have it OK. But</span>
00962 <span class="comment">// that is scary if it is done when already in hard real time, and we do not</span>
00963 <span class="comment">// want to force users to call this before making it hard.</span>
00964                 rtai_lxrt(BIDX, SIZARG, HRT_USE_FPU, &amp;arg);
00965                 <span class="keywordflow">return</span> 0;
00966         }
00967 }
00968 
00969 RTAI_PROTO(<span class="keywordtype">int</span>,rt_buddy_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
00970 {
00971         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
00972         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
00973 }
00974 
00975 RTAI_PROTO(<span class="keywordtype">int</span>,rt_linux_use_fpu,(<span class="keywordtype">int</span> use_fpu_flag))
00976 {
00977         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> use_fpu_flag; } arg = { use_fpu_flag };
00978         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LINUX_USE_FPU, &amp;arg).i[LOW];
00979 }
00980 
00981 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always,(<span class="keywordtype">int</span> yes_no))
00982 {
00983         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; } arg = { yes_no };
00984         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_GEN, &amp;arg);
00985 }
00986 
00987 RTAI_PROTO(RTIME,rt_get_time_ns,(<span class="keywordtype">void</span>))
00988 {
00989         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00990         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS, &amp;arg).rt;
00991 }
00992 
00993 RTAI_PROTO(RTIME,rt_get_cpu_time_ns,(<span class="keywordtype">void</span>))
00994 {
00995         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00996         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_CPU_TIME_NS, &amp;arg).rt;
00997 }
00998 
00999 <span class="preprocessor">#define rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal) \</span>
01000 <span class="preprocessor">        rt_task_init(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal)</span>
01001 <span class="preprocessor"></span>
01002 <span class="preprocessor">#define rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu) \</span>
01003 <span class="preprocessor">        rt_task_init_cpuid(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu)</span>
01004 <span class="preprocessor"></span>
01005 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpus,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask))
01006 {
01007         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask; } arg = { task, cpu_mask };
01008         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUS, &amp;arg);
01009 }
01010 
01011 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpuid,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01012 {
01013         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { task, cpuid };
01014         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUID, &amp;arg);
01015 }
01016 
01017 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_timer_cpu,(<span class="keywordtype">void</span>))
01018 {
01019         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01020         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIMER_CPU, &amp;arg).i[LOW];
01021 }
01022 
01023 RTAI_PROTO(<span class="keywordtype">void</span>,start_rt_apic_timers,(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid))
01024 {
01025         <span class="keyword">struct </span>{ <span class="keyword">struct </span>apic_timer_setup_data *setup_mode; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid; } arg = { setup_mode, rcvr_jiffies_cpuid };
01026         rtai_lxrt(BIDX, SIZARG, START_RT_APIC_TIMERS, &amp;arg);
01027 }
01028 
01029 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always_cpuid,(<span class="keywordtype">int</span> yes_no, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01030 {
01031         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { yes_no, cpuid };
01032         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_CPUID, &amp;arg);
01033 }
01034 
01035 RTAI_PROTO(RTIME,count2nano_cpuid,(RTIME count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01036 {
01037         <span class="keyword">struct </span>{ RTIME count; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { count, cpuid };
01038         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO_CPUID, &amp;arg).rt;
01039 }
01040 
01041 RTAI_PROTO(RTIME,nano2count_cpuid,(RTIME nanos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01042 {
01043         <span class="keyword">struct </span>{ RTIME nanos; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { nanos, cpuid };
01044         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT_CPUID, &amp;arg).rt;
01045 }
01046 
01047 RTAI_PROTO(RTIME,rt_get_time_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01048 {
01049         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01050         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_CPUID, &amp;arg).rt;
01051 }
01052 
01053 RTAI_PROTO(RTIME,rt_get_time_ns_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01054 {
01055         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01056         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS_CPUID, &amp;arg).rt;
01057 }
01058 
01059 RTAI_PROTO(<span class="keywordtype">void</span>,rt_boom,(<span class="keywordtype">void</span>))
01060 {
01061         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
01062         rtai_lxrt(BIDX, SIZARG, RT_BOOM, &amp;arg);
01063 }
01064 
01065 RTAI_PROTO(<span class="keywordtype">void</span>,rt_mmgr_stats,(<span class="keywordtype">void</span>))
01066 {
01067         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
01068         rtai_lxrt(BIDX, SIZARG, RT_MMGR_STATS, &amp;arg);
01069 }
01070 
01071 RTAI_PROTO(<span class="keywordtype">void</span>,rt_stomp,(<span class="keywordtype">void</span>) )
01072 {
01073         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
01074         rtai_lxrt(BIDX, SIZARG, RT_STOMP, &amp;arg);
01075 }
01076 
01077 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_linux_signal,(RT_TASK *task))
01078 {
01079     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01080     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_LINUX_SIGNAL, &amp;arg).i[LOW];
01081 }
01082 
01083 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_errno,(RT_TASK *task))
01084 {
01085     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01086     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_ERRNO, &amp;arg).i[LOW];
01087 }
01088 
01089 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_linux_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">int</span> sig)))
01090 {
01091     <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(<span class="keywordtype">int</span> sig); } arg = { task, handler };
01092     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_SET_LINUX_SIGNAL_HANDLER, &amp;arg).i[LOW];
01093 }
01094 
01095 RTAI_PROTO(<span class="keywordtype">int</span>, rt_lxrt_fork,(<span class="keywordtype">int</span> is_a_clone))
01096 {
01097     <span class="keyword">struct </span>{ <span class="keywordtype">int</span> is_a_clone; } arg = { is_a_clone };
01098     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_FORK, &amp;arg).i[LOW];
01099 }
01100 
01101 RTAI_PROTO(<span class="keywordtype">int</span>,rtai_print_to_screen,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
01102 {
01103         <span class="keywordtype">char</span> display[256];
01104         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
01105         va_list args;
01106 
01107         va_start(args, format);
01108         arg.nch = vsprintf(display, format, args);
01109         va_end(args);
01110         rtai_lxrt(BIDX, SIZARG, PRINT_TO_SCREEN, &amp;arg);
01111         <span class="keywordflow">return</span> arg.nch;
01112 }
01113 
01114 RTAI_PROTO(<span class="keywordtype">int</span>,rt_printk,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
01115 {
01116         <span class="keywordtype">char</span> display[256];
01117         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
01118         va_list args;
01119 
01120         va_start(args, format);
01121         arg.nch = vsprintf(display, format, args);
01122         va_end(args);
01123         rtai_lxrt(BIDX, SIZARG, PRINTK, &amp;arg);
01124         <span class="keywordflow">return</span> arg.nch;
01125 }
01126 
01127 RTAI_PROTO(<span class="keywordtype">int</span>,rt_usp_signal_handler,(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
01128 {
01129         <span class="keyword">struct </span>{ void (*handler)(void); } arg = { handler };
01130         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, USP_SIGHDL, &amp;arg).i[0];
01131 }
01132 
01133 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags,(RT_TASK *rt_task))
01134 {
01135         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01136         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLAGS, &amp;arg).i[LOW];
01137 }
01138 
01139 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags_mask,(RT_TASK *rt_task))
01140 {
01141         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01142         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLG_MSK, &amp;arg).i[LOW];
01143 }
01144 
01145 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags,(RT_TASK *rt_task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags))
01146 {
01147         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags; } arg = { rt_task, flags };
01148         rtai_lxrt(BIDX, SIZARG, SET_USP_FLAGS, &amp;arg);
01149 }
01150 
01151 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags_mask,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask))
01152 {
01153         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask; } arg = { flags_mask };
01154         rtai_lxrt(BIDX, SIZARG, SET_USP_FLG_MSK, &amp;arg);
01155 }
01156 
01157 RTAI_PROTO(RT_TASK *,rt_force_task_soft,(<span class="keywordtype">int</span> pid))
01158 {
01159         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> pid; } arg = { pid };
01160         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, FORCE_TASK_SOFT, &amp;arg).v[LOW];
01161 }
01162 
01163 RTAI_PROTO(RT_TASK *,rt_agent,(<span class="keywordtype">void</span>))
01164 {
01165         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01166         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW];
01167 }
01168 
01169 <span class="preprocessor">#define rt_buddy() rt_agent()</span>
01170 <span class="preprocessor"></span>
<a name="l01193"></a><a class="code" href="group__lxrt.html#ga73">01193</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_make_hard_real_time,(<span class="keywordtype">void</span>))
01194 {
01195         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01196         rtai_lxrt(BIDX, SIZARG, MAKE_HARD_RT, &amp;arg);
01197 }
01198 
<a name="l01207"></a><a class="code" href="group__lxrt.html#ga74">01207</a> RTAI_PROTO(<span class="keywordtype">void</span>,rt_allow_nonroot_hrt,(<span class="keywordtype">void</span>))
01208 {
01209         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01210         rtai_lxrt(BIDX, SIZARG, NONROOT_HRT, &amp;arg);
01211 }
01212 
01213 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_real_time,(RT_TASK *rt_task))
01214 {
01215         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01216         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IS_HARD, &amp;arg).i[LOW];
01217 }
01218 
01219 <span class="preprocessor">#define rt_is_soft_real_time(rt_task) (!rt_is_hard_real_time((rt_task)))</span>
01220 <span class="preprocessor"></span>
01221 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_set_resume_end_times,(RTIME resume, RTIME end))
01222 {
01223         <span class="keyword">struct </span>{ RTIME resume, end; } arg = { resume, end };
01224         rtai_lxrt(BIDX, SIZARG, SET_RESUME_END, &amp;arg);
01225 }
01226 
01227 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_resume_time,(RT_TASK *rt_task, RTIME new_resume_time))
01228 {
01229         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_resume_time; } arg = { rt_task, new_resume_time };
01230         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_RESUME_TIME, &amp;arg).i[LOW];
01231 }
01232 
01233 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_period,(RT_TASK *rt_task, RTIME new_period))
01234 {
01235         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_period; } arg = { rt_task, new_period };
01236         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_PERIOD, &amp;arg).i[LOW];
01237 }
01238 
01239 RTAI_PROTO(<span class="keywordtype">void</span>,rt_spv_RMS,(<span class="keywordtype">int</span> cpuid))
01240 {
01241         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01242         rtai_lxrt(BIDX, SIZARG, SPV_RMS, &amp;arg);
01243 }
01244 
01245 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_wakeup_sleeping,(RT_TASK *task))
01246 {
01247         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01248         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, WAKEUP_SLEEPING, &amp;arg).i[LOW];
01249 }
01250 
01251 RTAI_PROTO(<span class="keywordtype">void</span>,rt_get_exectime,(RT_TASK *task, RTIME *exectime))
01252 {
01253         RTIME lexectime[] = { 0LL, 0LL, 0LL };
01254         <span class="keyword">struct </span>{ RT_TASK *task; RTIME *lexectime; } arg = { task, lexectime };
01255         rtai_lxrt(BIDX, SIZARG, GET_EXECTIME, &amp;arg);
01256         memcpy(exectime, lexectime, <span class="keyword">sizeof</span>(lexectime));
01257 }
01258 
01259 RTAI_PROTO(<span class="keywordtype">void</span>,rt_gettimeorig,(RTIME time_orig[]))
01260 {
01261         <span class="keyword">struct </span>{ RTIME *time_orig; } arg = { time_orig };
01262         rtai_lxrt(BIDX, SIZARG, GET_TIMEORIG, &amp;arg);
01263 }
01264 
01265 <span class="preprocessor">#ifdef __cplusplus</span>
01266 <span class="preprocessor"></span>}
01267 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01268 
01269 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01270 
01273 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_LXRT_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:52 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
