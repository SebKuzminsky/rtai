<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_tbx.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a></div>
<h1>rtai_tbx.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2001  G.M. Bertani &lt;gmbertani@yahoo.it&gt;</span>
00003 <span class="comment"> * Copyright (C) 2002  P. Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00004 <span class="comment"> *                       (LXRT extensions).</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00007 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00008 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00009 <span class="comment"> * License, or (at your option) any later version.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00014 <span class="comment"> * GNU General Public License for more details.</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00017 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00018 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="preprocessor">#ifndef _RTAI_TBX_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_TBX_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00025 
00026 <span class="comment">/* TYPED MAILBOXES */</span>
00027 
00028 <span class="preprocessor">#define RT_TBX_MAGIC 0x6e93ad4b</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#define TYPE_NONE      0x00</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_NORMAL    0x01</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_BROADCAST 0x02</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_URGENT    0x04</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#ifdef __KERNEL__</span>
00036 <span class="preprocessor"></span>
00037 <span class="keyword">struct </span>rt_typed_mailbox;
00038 
00039 <span class="preprocessor">#ifndef __cplusplus</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00042 
00043 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_typed_mailbox {
00044 
00045     <span class="keywordtype">int</span> magic;
00046     <span class="keywordtype">int</span> waiting_nr;   <span class="comment">/* number of tasks waiting for a broadcast */</span>
00047     SEM sndsmx, rcvsmx;
00048     SEM bcbsmx;       <span class="comment">/* binary sem needed to wakeup the sleeping tasks </span>
00049 <span class="comment">                      when the broadcasting of a message is terminated */</span>
00050     RT_TASK *waiting_task;
00051     <span class="keywordtype">char</span> *bufadr;     <span class="comment">/* mailbox buffer */</span>
00052     <span class="keywordtype">char</span> *bcbadr;     <span class="comment">/* broadcasting buffer */</span>
00053     <span class="keywordtype">int</span> size;         <span class="comment">/* mailbox size */</span>
00054     <span class="keywordtype">int</span> fbyte;        <span class="comment">/* circular buffer read pointer */</span>
00055     <span class="keywordtype">int</span> avbs;         <span class="comment">/* bytes occupied */</span>
00056     <span class="keywordtype">int</span> frbs;         <span class="comment">/* bytes free */</span>
00057     spinlock_t buflock;
00058 
00059 } TBX;
00060 
00061 <span class="preprocessor">#else </span><span class="comment">/* __cplusplus */</span>
00062 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00063 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00064 
00065 <span class="keywordtype">int</span> __rtai_tbx_init(<span class="keywordtype">void</span>);
00066 
00067 <span class="keywordtype">void</span> __rtai_tbx_exit(<span class="keywordtype">void</span>);
00068 
00069 <span class="comment">/*</span>
00070 <span class="comment"> * send_wp and receive_wp are not implemented because </span>
00071 <span class="comment"> * the packed message must be sent/received atomically</span>
00072 <span class="comment"> */</span> 
00073 
00074 <span class="keywordtype">int</span> rt_tbx_init(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00075                 <span class="keywordtype">int</span> size,
00076                 <span class="keywordtype">int</span> flags);
00077 
00078 <span class="keywordtype">int</span> rt_tbx_delete(<span class="keyword">struct</span> rt_typed_mailbox *tbx);
00079 
00080 <span class="keywordtype">int</span> rt_tbx_send(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00081                 <span class="keywordtype">void</span> *msg,
00082                 <span class="keywordtype">int</span> msg_size);
00083 
00084 <span class="keywordtype">int</span> rt_tbx_send_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00085                    <span class="keywordtype">void</span> *msg,
00086                    <span class="keywordtype">int</span> msg_size);
00087 
00088 <span class="keywordtype">int</span> rt_tbx_send_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00089                       <span class="keywordtype">void</span> *msg,
00090                       <span class="keywordtype">int</span> msg_size,
00091                       RTIME time);
00092 
00093 <span class="keywordtype">int</span> rt_tbx_send_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00094                       <span class="keywordtype">void</span> *msg,
00095                       <span class="keywordtype">int</span> msg_size,
00096                       RTIME delay);
00097 
00098 <span class="keywordtype">int</span> rt_tbx_receive(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00099                    <span class="keywordtype">void</span> *msg,
00100                    <span class="keywordtype">int</span> msg_size);
00101 
00102 <span class="keywordtype">int</span> rt_tbx_receive_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00103                       <span class="keywordtype">void</span> *msg,
00104                       <span class="keywordtype">int</span> msg_size);
00105 
00106 <span class="keywordtype">int</span> rt_tbx_receive_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00107                          <span class="keywordtype">void</span> *msg,
00108                          <span class="keywordtype">int</span> msg_size,
00109                          RTIME time);
00110 
00111 <span class="keywordtype">int</span> rt_tbx_receive_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00112                          <span class="keywordtype">void</span> *msg,
00113                          <span class="keywordtype">int</span> msg_size,
00114                          RTIME delay);
00115 
00116 <span class="keywordtype">int</span> rt_tbx_broadcast(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00117                      <span class="keywordtype">void</span> *msg,
00118                      <span class="keywordtype">int</span> msg_size);
00119 
00120 <span class="keywordtype">int</span> rt_tbx_broadcast_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00121                         <span class="keywordtype">void</span> *msg,
00122                         <span class="keywordtype">int</span> msg_size);
00123 
00124 <span class="keywordtype">int</span> rt_tbx_broadcast_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00125                            <span class="keywordtype">void</span> *msg,
00126                            <span class="keywordtype">int</span> msg_size,
00127                            RTIME time);
00128 
00129 <span class="keywordtype">int</span> rt_tbx_broadcast_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00130                            <span class="keywordtype">void</span> *msg,
00131                            <span class="keywordtype">int</span> msg_size,
00132                            RTIME delay);
00133 
00134 <span class="keywordtype">int</span> rt_tbx_urgent(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00135                   <span class="keywordtype">void</span> *msg,
00136                   <span class="keywordtype">int</span> msg_size);
00137 
00138 <span class="keywordtype">int</span> rt_tbx_urgent_if(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00139                      <span class="keywordtype">void</span> *msg,
00140                      <span class="keywordtype">int</span> msg_size);
00141 
00142 <span class="keywordtype">int</span> rt_tbx_urgent_until(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00143                         <span class="keywordtype">void</span> *msg,
00144                         <span class="keywordtype">int</span> msg_size,
00145                         RTIME time);
00146 
00147 <span class="keywordtype">int</span> rt_tbx_urgent_timed(<span class="keyword">struct</span> rt_typed_mailbox *tbx,
00148                         <span class="keywordtype">void</span> *msg,
00149                         <span class="keywordtype">int</span> msg_size,
00150                         RTIME delay);
00151 
00152 <span class="preprocessor">#ifdef __cplusplus</span>
00153 <span class="preprocessor"></span>}
00154 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00155 
00156 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00157 
00158 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00159 
00160 <span class="preprocessor">#define TBXIDX 0</span>
00161 <span class="preprocessor"></span>
00162 <span class="preprocessor">#ifdef __cplusplus</span>
00163 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00164 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00165 
00166 RTAI_PROTO(<span class="keyword">struct</span> rt_typed_mailbox *, rt_tbx_init,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flags))
00167 {
00168         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name; <span class="keywordtype">int</span> size; <span class="keywordtype">int</span> flags; } arg = { name, size, flags };
00169         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_typed_mailbox *)rtai_lxrt(TBXIDX, SIZARG, TBX_INIT, &amp;arg).v[LOW];
00170 }
00171 
00172 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_delete,(<span class="keyword">struct</span> rt_typed_mailbox *tbx))
00173 {
00174         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; } arg = { tbx };
00175         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_DELETE, &amp;arg).i[LOW];
00176 }
00177 
00178 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00179 {
00180         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00181         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND, &amp;arg).i[LOW];
00182 }
00183 
00184 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00185 {
00186         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00187         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND_IF, &amp;arg).i[LOW];
00188 }
00189 
00190 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00191 {
00192         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00193         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND_UNTIL, &amp;arg).i[LOW];
00194 }
00195 
00196 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_send_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00197 {
00198         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00199         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_SEND_TIMED, &amp;arg).i[LOW];
00200 }
00201 
00202 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00203 {
00204         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00205         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE, &amp;arg).i[LOW];
00206 }
00207 
00208 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00209 {
00210         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00211         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE_IF, &amp;arg).i[LOW];
00212 }
00213 
00214 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00215 {
00216         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00217         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE_UNTIL, &amp;arg).i[LOW];
00218 }
00219 
00220 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_receive_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00221 {
00222         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00223         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_RECEIVE_TIMED, &amp;arg).i[LOW];
00224 }
00225 
00226 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00227 {
00228         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00229         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST, &amp;arg).i[LOW];
00230 }
00231 
00232 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00233 {
00234         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00235         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST_IF, &amp;arg).i[LOW];
00236 }
00237 
00238 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00239 {
00240         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00241         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST_UNTIL, &amp;arg).i[LOW];
00242 }
00243 
00244 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_broadcast_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00245 {
00246         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00247         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_BROADCAST_TIMED, &amp;arg).i[LOW];
00248 }
00249 
00250 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00251 {
00252         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00253         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT, &amp;arg).i[LOW];
00254 }
00255 
00256 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent_if,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size))
00257 {
00258         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; } arg = { tbx, msg, msg_size };
00259         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT_IF, &amp;arg).i[LOW];
00260 }
00261 
00262 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent_until,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME time))
00263 {
00264         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME time; } arg = { tbx, msg, msg_size, time };
00265         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT_UNTIL, &amp;arg).i[LOW];
00266 }
00267 
00268 RTAI_PROTO(<span class="keywordtype">int</span>, rt_tbx_urgent_timed,(<span class="keyword">struct</span> rt_typed_mailbox *tbx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, RTIME delay))
00269 {
00270         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_typed_mailbox *tbx; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; RTIME delay; } arg = { tbx, msg, msg_size, delay };
00271         <span class="keywordflow">return</span> rtai_lxrt(TBXIDX, SIZARG, TBX_URGENT_TIMED, &amp;arg).i[LOW];
00272 }
00273 
00274 <span class="preprocessor">#ifdef __cplusplus</span>
00275 <span class="preprocessor"></span>}
00276 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00277 
00278 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00279 
00280 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00281 <span class="preprocessor"></span>
00282 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_typed_mailbox {
00283     <span class="keywordtype">int</span> opaque;
00284 } TBX;
00285 
00286 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00287 
00288 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_TBX_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:52 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
