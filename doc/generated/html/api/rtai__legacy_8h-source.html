<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/asm-ppc/rtai_legacy.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000021.html">asm-ppc</a></div>
<h1>rtai_legacy.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">COPYRIGHT (C) 2000  Paolo Mantegazza (mantegazza@aero.polimi.it)</span>
00003 <span class="comment"></span>
00004 <span class="comment">This library is free software; you can redistribute it and/or</span>
00005 <span class="comment">modify it under the terms of the GNU Lesser General Public</span>
00006 <span class="comment">License as published by the Free Software Foundation; either</span>
00007 <span class="comment">version 2 of the License, or (at your option) any later version.</span>
00008 <span class="comment"></span>
00009 <span class="comment">This library is distributed in the hope that it will be useful,</span>
00010 <span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00012 <span class="comment">Lesser General Public License for more details.</span>
00013 <span class="comment"></span>
00014 <span class="comment">You should have received a copy of the GNU Lesser General Public</span>
00015 <span class="comment">License along with this library; if not, write to the Free Software</span>
00016 <span class="comment">Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.</span>
00017 <span class="comment">*/</span>
00018 
00019 
00020 <span class="preprocessor">#ifndef _RTAI_ASM_PPC_RTAI_H_</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_ASM_PPC_RTAI_H_</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00024 
00025 <span class="comment">// These are truly PPC specific.</span>
00026 <span class="preprocessor">#define LATENCY_DECR 2500 </span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define SETUP_TIME_DECR 500 </span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">// CPU frequency calibration</span>
00030 <span class="preprocessor">#define CPU_FREQ (tuned.cpu_freq)</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define FREQ_DECR CPU_FREQ</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define CALIBRATED_CPU_FREQ     0 // Use this if you know better than Linux!</span>
00033 <span class="preprocessor"></span>
00034 <span class="comment">// Do not be messed up by macros names below, is a trick for keeping i386 code.</span>
00035 <span class="preprocessor">#define FREQ_8254 FREQ_DECR</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define FREQ_APIC FREQ_DECR</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define LATENCY_8254 3000</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define SETUP_TIME_8254 500</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define TIMER_8254_IRQ 0xFFFFFFFF</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#define IFLAG 15</span>
00042 <span class="preprocessor"></span>
00043 <span class="preprocessor">#define RTAI_NR_TRAPS 32</span>
00044 <span class="preprocessor"></span>
00045 <span class="comment">// These and the related vector are of no use, at the moment.</span>
00046 <span class="preprocessor">#define RTAI_1_IPI  6</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_2_IPI  7</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_3_IPI  8</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_4_IPI  9</span>
00050 <span class="preprocessor"></span>
00051 <span class="preprocessor">#define RTAI_1_VECTOR  0xD9</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_2_VECTOR  0xE1</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_3_VECTOR  0xE9</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_4_VECTOR  0xF1</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#define RT_TIME_END 0x7FFFFFFFFFFFFFFFLL</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#ifdef INLINE_MATH</span>
00059 <span class="preprocessor"></span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullmul(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m0, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m1);
00060 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ulldiv(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uld, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *r);
00061 <span class="keywordtype">int</span> imuldiv(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> mult, <span class="keywordtype">int</span> div);
00062 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> llimd(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mult, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> div);
00063 <span class="preprocessor">#else </span><span class="comment">/* !INLINE_MATH */</span>
00064 <span class="comment">// One of the silly thing of 32 bits PPCs, no 64 bits result for 32 bits mul.</span>
00065 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullmul(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m0, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m1)
00066 {
00067         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> res;
00068 
00069         __asm__ __volatile__ (<span class="stringliteral">"mulhwu %0, %1, %2"</span>
00070         : <span class="stringliteral">"=r"</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;res)[0]) : <span class="stringliteral">"%r"</span> (m0), <span class="stringliteral">"r"</span> (m1));
00071         ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;res)[1] = m0*m1;
00072 
00073         <span class="keywordflow">return</span> res;
00074 
00075 }
00076 
00077 <span class="comment">// One of the silly thing of 32 bits PPCs, no 64 by 32 bits divide.</span>
00078 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ulldiv(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uld, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *r)
00079 {
00080         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> q, rf;
00081         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> qh, rh, ql, qf;
00082 
00083         q = 0;
00084         rf = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)(0xFFFFFFFF - (qf = 0xFFFFFFFF / uld) * uld) + 1ULL;
00085 
00086         <span class="keywordflow">while</span> (ull &gt;= uld) {
00087                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;q)[0] += (qh = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0] / uld);
00088                 rh = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0] - qh * uld;
00089                 q += rh * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)qf + (ql = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1] / uld);
00090                 ull = rh * rf + (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1] - ql * uld);
00091         }
00092 
00093         *r = ull;
00094         <span class="keywordflow">return</span> q;
00095 }
00096 
00097 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> imuldiv(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> mult, <span class="keywordtype">int</span> div)
00098 {
00099         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> q, r;
00100 
00101         q = ulldiv(ullmul(i, mult), div, &amp;r);
00102 
00103         <span class="keywordflow">return</span> (r + r) &gt; div ? q + 1 : q;
00104 }
00105 
00106 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> llimd(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mult, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> div)
00107 {
00108         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> low;
00109         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> q, r;
00110 
00111         low  = ullmul(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[1], mult);        
00112         q = ulldiv( ullmul(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ull)[0], mult) + ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;low)[0], div, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;low);
00113         low = ulldiv(low, div, &amp;r);
00114         ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;low)[0] += q;
00115 
00116         <span class="keywordflow">return</span> (r + r) &gt; div ? low + 1 : low;
00117 }
00118 <span class="preprocessor">#endif </span><span class="comment">/* INLINE_MATH */</span>
00119 
00120 <span class="preprocessor">#ifdef __KERNEL__</span>
00121 <span class="preprocessor"></span>
00122 <span class="preprocessor">#ifndef __cplusplus</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/types.h&gt;</span>
00124 <span class="preprocessor">#include &lt;linux/rtc.h&gt;</span>          <span class="comment">/* to avoid warnings in time.h */</span>
00125 <span class="preprocessor">#include &lt;asm/time.h&gt;</span>
00126 <span class="preprocessor">#include &lt;linux/kernel.h&gt;</span>
00127 <span class="preprocessor">#include &lt;linux/smp.h&gt;</span>
00128 <span class="preprocessor">#include &lt;linux/irq.h&gt;</span>
00129 <span class="preprocessor">#include &lt;asm/page.h&gt;</span>
00130 <span class="preprocessor">#include &lt;asm/ptrace.h&gt;</span>
00131 <span class="preprocessor">#include &lt;asm/hw_irq.h&gt;</span>
00132 <span class="preprocessor">#include &lt;asm/processor.h&gt;</span>
00133 <span class="preprocessor">#include &lt;asm/bitops.h&gt;</span>
00134 <span class="preprocessor">#include &lt;asm/rtai_fpu.h&gt;</span>
00135 <span class="preprocessor">#include &lt;asm/rtai_atomic.h&gt;</span>
00136 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00137 
00138 <span class="comment">// Write to parallel port if present</span>
00139 <span class="preprocessor">#if defined(CONFIG_PPC)</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define LPT_OUTB(v) do { } while (0)</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define LPT_OUTB(v) do { outb(v,0x378); } while(0)</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00144 <span class="preprocessor"></span>
00145 <span class="keyword">struct </span>apic_timer_setup_data { <span class="keywordtype">int</span> mode, count; };
00146 
00147 <span class="keyword">struct </span>desc_struct { <span class="keywordtype">void</span> *fun; };
00148 
00149 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> *locked_cpus;
00150 
00151 <span class="keyword">extern</span> <span class="keywordtype">void</span> send_ipi_shorthand(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shorthand, <span class="keywordtype">int</span> irq);
00152 <span class="keyword">extern</span> <span class="keywordtype">void</span> send_ipi_logical(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dest, <span class="keywordtype">int</span> irq);
00153 <span class="preprocessor">#define rt_assign_irq_to_cpu(irq, cpu)</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define rt_reset_irq_to_sym_mode(irq)</span>
00155 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span>  rt_request_global_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq));
00156 <span class="keyword">extern</span> <span class="keywordtype">int</span>  rt_request_global_irq_arg(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq,
00157                 <span class="keywordtype">int</span> (*handler)(<span class="keywordtype">int</span>,<span class="keywordtype">void</span> *,<span class="keyword">struct</span> pt_regs *),
00158                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags,<span class="keyword">const</span> <span class="keywordtype">char</span> *dev,<span class="keywordtype">void</span> *dev_id);
00159 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_request_global_irq_ext(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, 
00160                                      <span class="keywordtype">int</span> (*handler)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> handler), 
00161                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data);
00162 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_set_global_irq_ext(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">int</span> ext, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data);
00163 <span class="keyword">extern</span> <span class="keywordtype">int</span>  rt_free_global_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00164 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__hal.html#ga80">rt_ack_irq</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00165 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__hal.html#ga78">rt_mask_and_ack_irq</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00166 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_unmask_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00167 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rt_startup_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00168 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_shutdown_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00169 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_enable_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00170 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_disable_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00171 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_request_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq,
00172         <span class="keywordtype">void</span> (*linux_handler)(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs), 
00173         <span class="keywordtype">char</span> *linux_handler_id, <span class="keywordtype">void</span> *dev_id);
00174 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_free_linux_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id);
00175 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__hal.html#ga84">rt_pend_linux_irq</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq);
00176 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_tick_linux_timer(<span class="keywordtype">void</span>);
00177 <span class="keyword">extern</span> <span class="keyword">struct </span>desc_struct rt_set_full_intr_vect(unsigned int vector, int type, int dpl, void *handler);
00178 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_reset_full_intr_vect(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vector, <span class="keyword">struct</span> desc_struct idt_element);
00179 <span class="preprocessor">#define rt_set_intr_handler(vector, handler) ((void *)0)</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define rt_reset_intr_handler(vector, handler)</span>
00181 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> rt_request_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> label, <span class="keywordtype">void</span> (*rtai_handler)(<span class="keywordtype">void</span>), <span class="keywordtype">long</span> <span class="keywordtype">long</span> (*user_handler)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> whatever));
00182 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_free_srq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srq);
00183 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__hal.html#ga87">rt_pend_linux_srq</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> srq);
00184 <span class="preprocessor">#define rt_request_cpu_own_irq(irq, handler) rt_request_global_irq((irq), (handler))</span>
00185 <span class="preprocessor"></span><span class="preprocessor">#define rt_free_cpu_own_irq(irq) rt_free_global_irq((irq))</span>
00186 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> rt_request_timer(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>), <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tick, <span class="keywordtype">int</span> apic);
00187 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group__hal.html#ga94">rt_free_timer</a>(<span class="keywordtype">void</span>);
00188 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_request_apic_timers(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>), <span class="keyword">struct</span> apic_timer_setup_data *apic_timer_data);
00189 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_free_apic_timers(<span class="keywordtype">void</span>);
00190 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_mount_rtai(<span class="keywordtype">void</span>);
00191 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_umount_rtai(<span class="keywordtype">void</span>);
00192 <span class="keyword">extern</span> <span class="keywordtype">int</span> rt_printk(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
00193 <span class="keyword">extern</span> <span class="keywordtype">int</span> rtai_print_to_screen(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...);
00194 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_switch_to_linux(<span class="keywordtype">int</span> cpuid);
00195 <span class="keyword">extern</span> <span class="keywordtype">void</span> rt_switch_to_real_time(<span class="keywordtype">int</span> cpuid);
00196 
00197 <span class="preprocessor">#ifndef DEBUG_FLAGS</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define debug_flags_set(ptr,a)</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define debug_flags_check(ptr)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00201 <span class="preprocessor"></span><span class="keywordtype">void</span> debug_flags_set(<span class="keywordtype">void</span> *ptr,<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags);
00202 <span class="keywordtype">void</span> debug_flags_check(<span class="keywordtype">void</span> *ptr);
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>
00205 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> hard_cli(<span class="keywordtype">void</span>)
00206 {
00207         debug_flags_set(__builtin_return_address(0),0);
00208         __asm__ __volatile__ (
00209                 <span class="stringliteral">"\tmfmsr        0\n"</span>
00210                 <span class="comment">//"\trlwinm     3,0,16+1,32-1,31\n"</span>
00211                 <span class="stringliteral">"\trlwinm       0,0,0,17,15\n"</span>
00212                 <span class="stringliteral">"\tmtmsr        0\n"</span>
00213                 : : : <span class="stringliteral">"r0"</span>
00214         );
00215 }
00216 
00217 
00218 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> hard_restore_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags)
00219 {
00220         debug_flags_set(__builtin_return_address(0),flags);
00221         __asm__ __volatile__ (
00222                 <span class="stringliteral">"\tmfmsr        0\n"</span>
00223                 <span class="stringliteral">"\trlwimi       %0,0,0,17,15\n"</span>
00224                 <span class="stringliteral">"\tmtmsr        %0\n"</span>
00225         : : <span class="stringliteral">"r"</span> (flags) : <span class="stringliteral">"r0"</span>
00226         );
00227 }
00228         
00229 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> hard_sti(<span class="keywordtype">void</span>)
00230 {
00231         debug_flags_set(__builtin_return_address(0),MSR_EE);
00232         __asm__ __volatile__ (
00233                 <span class="stringliteral">"\tmfmsr        0\n"</span>
00234                 <span class="stringliteral">"\tori          0,0,(1&lt;&lt;15)\n"</span>
00235                 <span class="stringliteral">"\tmtmsr        0\n"</span>
00236                 : : : <span class="stringliteral">"r0"</span>
00237         );
00238 }
00239 
00240 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> __hard_save_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *flags)
00241 {
00242         __asm__ __volatile__ (
00243                 <span class="stringliteral">"\tmfmsr        %0\n"</span>
00244                 : <span class="stringliteral">"=r"</span> (*flags)
00245         );
00246 }
00247 
00248 <span class="preprocessor">#define hard_save_flags(flags)         do { __hard_save_flags(&amp;(flags)); } while (0)</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define hard_save_flags_and_cli(flags) do { __hard_save_flags(&amp;(flags)); hard_cli(); } while (0)</span>
00250 <span class="preprocessor"></span>
00251 <span class="preprocessor">#ifdef CONFIG_SMP</span>
00252 <span class="preprocessor"></span>
00253 <span class="preprocessor">#define rt_spin_lock(lock) spin_lock((lock))</span>
00254 <span class="preprocessor"></span>
00255 <span class="preprocessor">#define rt_spin_unlock(lock) spin_unlock((lock))</span>
00256 <span class="preprocessor"></span>
00257 <span class="preprocessor">#define hard_cpu_id()  hard_smp_processor_id() </span>
00258 <span class="preprocessor"></span>
00259 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_get_global_lock(<span class="keywordtype">void</span>)
00260 {
00261         hard_cli();
00262         <span class="keywordflow">if</span> (!test_and_set_bit(hard_cpu_id(), locked_cpus)) {
00263                 <span class="keywordflow">while</span> (test_and_set_bit(31, locked_cpus));
00264         }
00265 }
00266 
00267 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_release_global_lock(<span class="keywordtype">void</span>)
00268 {
00269         hard_cli();
00270         <span class="keywordflow">if</span> (test_and_clear_bit(hard_cpu_id(), locked_cpus)) {
00271                 clear_bit(31, locked_cpus);
00272         }
00273 }
00274 
00276 <span class="comment">// If NR_RT_CPUS &gt; 8 RTAI must be changed as it cannot use APIC flat delivery</span>
00277 <span class="comment">// and the way processor[?].intr_flag is used must be changed (right now it</span>
00278 <span class="comment">// exploits the fact that the IF flags is at bit 16 so that bits 0-7 are used</span>
00279 <span class="comment">// to mark a cpu as Linux soft irq enabled/disabled. Bad but comfortable, it </span>
00280 <span class="comment">// will take a very very long time before I'll have available SMP with more</span>
00281 <span class="comment">// than 8 cpus. Right now they are only:</span>
00283 <span class="comment"></span><span class="preprocessor">#define NR_RT_CPUS  2</span>
00284 <span class="preprocessor"></span>
00285 <span class="preprocessor">#else  </span><span class="comment">/* !CONFIG_SMP */</span>
00286 
00287 <span class="preprocessor">#define rt_spin_lock(whatever)  </span>
00288 <span class="preprocessor"></span><span class="preprocessor">#define rt_spin_unlock(whatever)</span>
00289 <span class="preprocessor"></span>
00290 <span class="preprocessor">#define rt_get_global_lock()  hard_cli()</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define rt_release_global_lock()</span>
00292 <span class="preprocessor"></span>
00293 <span class="preprocessor">#define hard_cpu_id()  0</span>
00294 <span class="preprocessor"></span>
00295 <span class="preprocessor">#define NR_RT_CPUS  1</span>
00296 <span class="preprocessor"></span>
00297 <span class="preprocessor">#endif  </span><span class="comment">/* CONFIG_SMP */</span>
00298 
00299 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_lock_irq(spinlock_t *lock)          
00300 {
00301         hard_cli(); 
00302         rt_spin_lock(lock);
00303 }
00304 
00305 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_unlock_irq(spinlock_t *lock)
00306 {
00307         rt_spin_unlock(lock);
00308         hard_sti();
00309 }
00310 
00311 <span class="comment">// Note that the spinlock calling convention below for irqsave/restore is </span>
00312 <span class="comment">// sligtly different from the one used in Linux. Done on purpose to get an </span>
00313 <span class="comment">// error if you use Linux spinlocks in real time applications as they do not</span>
00314 <span class="comment">// guaranty any protection because of the soft irq disable. Be careful and </span>
00315 <span class="comment">// sure to call the other spinlocks the right way, as they are compatible </span>
00316 <span class="comment">// with Linux.</span>
00317 
00318 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rt_spin_lock_irqsave(spinlock_t *lock)          
00319 {
00320         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00321         hard_save_flags_and_cli(flags);
00322         rt_spin_lock(lock);
00323         <span class="keywordflow">return</span> flags;
00324 }
00325 
00326 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_spin_unlock_irqrestore(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags, spinlock_t *lock)
00327 {
00328         rt_spin_unlock(lock);
00329         hard_restore_flags(flags);
00330 }
00331 
00332 <span class="comment">/* Global interrupts and flags control (simplified, and modified, version of */</span>
00333 <span class="comment">/* similar global stuff in Linux irq.c).                                     */</span>
00334 
00335 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_cli(<span class="keywordtype">void</span>)
00336 {
00337         rt_get_global_lock();
00338 }
00339 
00340 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_sti(<span class="keywordtype">void</span>)
00341 {
00342         rt_release_global_lock();
00343         hard_sti();
00344 }
00345 
00346 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_global_save_flags_and_cli(<span class="keywordtype">void</span>)
00347 {
00348         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
00349 
00350         hard_save_flags_and_cli(flags);
00351         <span class="keywordflow">if</span> (!test_and_set_bit(hard_cpu_id(), locked_cpus)) {
00352                 <span class="keywordflow">while</span> (test_and_set_bit(31, locked_cpus));
00353                 <span class="keywordflow">return</span> ((flags &amp; (1 &lt;&lt; IFLAG)) + 1);
00354         } <span class="keywordflow">else</span> {
00355                 <span class="keywordflow">return</span> (flags &amp; (1 &lt;&lt; IFLAG));
00356         }
00357 }
00358 
00359 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_save_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *flags)
00360 {
00361         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> hflags, rflags;
00362 
00363         hard_save_flags_and_cli(hflags);
00364         hflags = hflags &amp; (1 &lt;&lt; IFLAG);
00365         rflags = hflags | !test_bit(hard_cpu_id(), locked_cpus);
00366         <span class="keywordflow">if</span> (hflags) {
00367                 hard_sti();
00368         }
00369         *flags = rflags;
00370 }
00371 
00372 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_global_restore_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags)
00373 {
00374         <span class="keywordflow">switch</span> (flags) {
00375                 <span class="keywordflow">case</span> (1 &lt;&lt; IFLAG) | 1:  rt_release_global_lock();
00376                                         hard_sti();
00377                                         <span class="keywordflow">break</span>;
00378                 <span class="keywordflow">case</span> (1 &lt;&lt; IFLAG) | 0:  rt_get_global_lock();
00379                                         hard_sti();
00380                                         <span class="keywordflow">break</span>;
00381                 <span class="keywordflow">case</span> (0 &lt;&lt; IFLAG) | 1:  rt_release_global_lock();
00382                                         <span class="keywordflow">break</span>;
00383                 <span class="keywordflow">case</span> (0 &lt;&lt; IFLAG) | 0:  rt_get_global_lock();
00384                                         <span class="keywordflow">break</span>;
00385         }
00386 }
00387 
00388 <span class="keyword">static</span> <span class="keyword">inline</span> RT_TRAP_HANDLER rt_set_rtai_trap_handler(RT_TRAP_HANDLER handler)
00389 {
00390         <span class="keywordflow">return</span> (RT_TRAP_HANDLER) 0;
00391 }
00392 
00393 <span class="keyword">struct </span>calibration_data {
00394         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpu_freq;
00395         <span class="keywordtype">int</span> latency;
00396         <span class="keywordtype">int</span> setup_time_TIMER_CPUNIT;
00397         <span class="keywordtype">int</span> setup_time_TIMER_UNIT;
00398         <span class="keywordtype">int</span> timers_tol[NR_RT_CPUS];
00399 };
00400 
00401 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_times rt_times;
00402 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_times rt_smp_times[NR_RT_CPUS];
00403 <span class="keyword">extern</span> <span class="keyword">struct </span>calibration_data tuned;
00404 
00405 <span class="preprocessor">#if 0</span>
00406 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> get_dec(<span class="keywordtype">void</span>)
00407 {
00408         <span class="keywordflow">return</span> (mfspr(SPRN_DEC));
00409 }
00410 
00411 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_dec(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val)
00412 {
00413         mtspr(SPRN_DEC, val);
00414 }
00415 <span class="preprocessor">#endif</span>
00416 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_4xx</span>
00417 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> get_dec_4xx(<span class="keywordtype">void</span>)
00418 {
00419         <span class="keywordflow">return</span> (mfspr(SPRN_PIT));
00420 }
00421 
00422 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_dec_4xx(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val)
00423 {
00424         mtspr(SPRN_PIT, val);
00425 }
00426 <span class="preprocessor">#endif</span>
00427 <span class="preprocessor"></span>
00428 <span class="preprocessor">#define DECLR_8254_TSC_EMULATION</span>
00429 <span class="preprocessor"></span><span class="preprocessor">#define TICK_8254_TSC_EMULATION</span>
00430 <span class="preprocessor"></span><span class="preprocessor">#define SETUP_8254_TSC_EMULATION</span>
00431 <span class="preprocessor"></span><span class="preprocessor">#define CLEAR_8254_TSC_EMULATION</span>
00432 <span class="preprocessor"></span>
00433 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> rdtsc(<span class="keywordtype">void</span>)
00434 {
00435         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ts;
00436         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> chk;
00437 <span class="comment">// The code below is as suggested in Motorola reference manual for 32 bits PPCs.</span>
00438         __asm__ __volatile__ (<span class="stringliteral">"1: mftbu %0; mftb %1; mftbu %2; cmpw %2,%0; bne 1b"</span>
00439         : <span class="stringliteral">"=r"</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ts)[0]), <span class="stringliteral">"=r"</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;ts)[1]), <span class="stringliteral">"=r"</span> (chk) );
00440 
00441         <span class="keywordflow">return</span> ts;
00442 }
00443 
00444 <span class="preprocessor">#define RT_BUG() do{hard_cli();BUG();}while(0)</span>
00445 <span class="preprocessor"></span>
00446 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_set_decrementer_count(<span class="keywordtype">int</span> delay)
00447 {
00448 <span class="comment">// NOTE: delay MUST be 0 if a periodic timer is being used.</span>
00449         <span class="keywordflow">if</span>(!delay)delay = rt_times.intr_time - rdtsc();
00450 
00451         <span class="keywordflow">if</span>(delay&lt;1){RT_BUG();}
00452 <span class="preprocessor">#ifdef CONFIG_4xx</span>
00453 <span class="preprocessor"></span>        set_dec_4xx(delay);
00454 <span class="preprocessor">#else</span>
00455 <span class="preprocessor"></span>        set_dec(delay);
00456 <span class="preprocessor">#endif</span>
00457 <span class="preprocessor"></span>}
00458 
00459 <span class="comment">// We like keeping it as for i386.</span>
00460 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ffnz(<span class="keywordtype">long</span> ul)
00461 {
00462         __asm__ __volatile__ (<span class="stringliteral">"cntlzw %0, %1"</span> : <span class="stringliteral">"=r"</span> (ul) : <span class="stringliteral">"r"</span> (ul &amp; (-ul)));
00463 
00464         <span class="keywordflow">return</span> 31 - ul;
00465 }
00466 
00467 <span class="preprocessor">#define rt_set_timer_delay(x)  rt_set_decrementer_count(x)</span>
00468 <span class="preprocessor"></span>
00469 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00470 
00471 <span class="preprocessor">#define RTAI_DEFAULT_TICK    200000</span>
00472 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_DEFAULT_STACKSZ 2000</span>
00473 <span class="preprocessor"></span>
00474 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_ASM_PPC_RTAI_H_ */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:52 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
