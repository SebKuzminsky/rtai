<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_sched.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a></div>
<h1>rtai_sched.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 1999-2003 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="preprocessor">#ifndef _RTAI_SCHED_H</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_SCHED_H</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include &lt;rtai.h&gt;</span>
00023 <span class="preprocessor">#ifndef __KERNEL__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00025 <span class="preprocessor">#include &lt;time.h&gt;</span>
00026 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00027 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00028 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00029 
00030 <span class="preprocessor">#define RT_SCHED_UP   1</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SMP  2</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MUP  3</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#define RT_SCHED_HIGHEST_PRIORITY  0</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LOWEST_PRIORITY   0x3fffFfff</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_LINUX_PRIORITY    0x7fffFfff</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define RT_SCHED_READY        1</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SUSPENDED    2</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_DELAYED      4</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEMAPHORE    8</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SEND        16</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RECEIVE     32</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RPC         64</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_RETURN     128</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_MBXSUSP    256</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define RT_SCHED_SFTRDY     512</span>
00048 <span class="preprocessor"></span>
00049 <span class="preprocessor">#define RT_IRQ_TASK         0</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define RT_IRQ_TASKLET      1</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define RT_IRQ_TASK_ERR     0x7FFFFFFF</span>
00052 <span class="preprocessor"></span>
00053 <span class="keyword">struct </span>rt_task_struct;
00054 
00055 <span class="preprocessor">#ifdef __KERNEL__</span>
00056 <span class="preprocessor"></span>
00057 <span class="preprocessor">#include &lt;linux/time.h&gt;</span>
00058 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00059 
00060 <span class="preprocessor">#define RT_TASK_MAGIC 0x754d2774</span>
00061 <span class="preprocessor"></span>
00062 <span class="preprocessor">#ifndef __cplusplus</span>
00063 <span class="preprocessor"></span>
00064 <span class="preprocessor">#include &lt;linux/sched.h&gt;</span>
00065 
00066 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_queue {
00067         <span class="keyword">struct </span>rt_queue *prev;
00068         <span class="keyword">struct </span>rt_queue *next;
00069         <span class="keyword">struct </span>rt_task_struct *task;
00070 } QUEUE;
00071 
00072 <span class="keyword">struct </span>mcb_t {
00073     <span class="keywordtype">void</span> *sbuf;
00074     <span class="keywordtype">int</span> sbytes;
00075     <span class="keywordtype">void</span> *rbuf;
00076     <span class="keywordtype">int</span> rbytes;
00077 };
00078 
00079 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_ExitHandler {
00080     <span class="comment">/* Exit handler functions are called like C++ destructors in</span>
00081 <span class="comment">       rt_task_delete(). */</span>
00082     <span class="keyword">struct </span>rt_ExitHandler *nxt;
00083     void (*fun) (<span class="keywordtype">void</span> *arg1, <span class="keywordtype">int</span> arg2);
00084     <span class="keywordtype">void</span> *arg1;
00085     <span class="keywordtype">int</span>   arg2;
00086 } XHDL;
00087 
00088 <span class="keyword">struct </span>rt_heap_t { <span class="keywordtype">void</span> *heap, *kadr, *uadr; };
00089 
00090 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00091 
00092     <span class="keywordtype">int</span> *stack;
00093     <span class="keywordtype">int</span> uses_fpu;
00094     <span class="keywordtype">int</span> magic;
00095     <span class="keyword">volatile</span> <span class="keywordtype">int</span> state, running;
00096     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> runnable_on_cpus;
00097     <span class="keywordtype">int</span> *stack_bottom;
00098     <span class="keyword">volatile</span> <span class="keywordtype">int</span> priority;
00099     <span class="keywordtype">int</span> base_priority;
00100     <span class="keywordtype">int</span> policy;
00101     <span class="keywordtype">int</span> sched_lock_priority;
00102     <span class="keyword">struct </span>rt_task_struct *prio_passed_to;
00103     RTIME period;
00104     RTIME resume_time;
00105     RTIME yield_time;
00106     <span class="keywordtype">int</span> rr_quantum;
00107     <span class="keywordtype">int</span> rr_remaining;
00108     <span class="keywordtype">int</span> suspdepth;
00109     <span class="keyword">struct </span>rt_queue queue;
00110     <span class="keywordtype">int</span> owndres;
00111     <span class="keyword">struct </span>rt_queue *blocked_on;
00112     <span class="keyword">struct </span>rt_queue msg_queue;
00113     <span class="keywordtype">int</span> tid;    <span class="comment">/* trace ID */</span>
00114     <span class="keywordtype">unsigned</span> msg;
00115     <span class="keyword">struct </span>rt_queue ret_queue;
00116     void (*signal)(void);
00117     FPU_ENV fpu_reg;
00118     <span class="keyword">struct </span>rt_task_struct *prev;
00119     <span class="keyword">struct </span>rt_task_struct *next;
00120     <span class="keyword">struct </span>rt_task_struct *tprev;
00121     <span class="keyword">struct </span>rt_task_struct *tnext;
00122     <span class="keyword">struct </span>rt_task_struct *rprev;
00123     <span class="keyword">struct </span>rt_task_struct *rnext;
00124 
00125     <span class="comment">/* Appended for calls from LINUX. */</span>
00126     <span class="keywordtype">int</span> *fun_args, *bstack;
00127     <span class="keyword">struct </span>task_struct *lnxtsk;
00128     <span class="keywordtype">long</span> <span class="keywordtype">long</span> retval;
00129     <span class="keywordtype">char</span> *msg_buf[2];
00130     <span class="keywordtype">int</span> max_msg_size[2];
00131     <span class="keywordtype">char</span> task_name[16];
00132     <span class="keywordtype">void</span> *system_data_ptr;
00133     <span class="keyword">struct </span>rt_task_struct *nextp;
00134     <span class="keyword">struct </span>rt_task_struct *prevp;
00135 
00136     <span class="comment">/* Added to support user specific trap handlers. */</span>
00137     RT_TRAP_HANDLER task_trap_handler[RTAI_NR_TRAPS];
00138 
00139     <span class="comment">/* Added from rtai-22. */</span>
00140     void (*usp_signal)(void);
00141     <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pstate;
00142     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags;
00143     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> usp_flags_mask;
00144     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> force_soft;
00145     <span class="keyword">volatile</span> <span class="keywordtype">int</span> is_hard;
00146 
00147     <span class="comment">/* Added to terminate qBlks. */</span>
00148     <span class="keywordtype">void</span> *tick_queue;
00149 
00150     <span class="comment">/* Added to terminate re-entry of user space functions. */</span>
00151 
00152     <span class="keywordtype">void</span> *trap_handler_data; 
00153     <span class="keywordtype">int</span> trap_signo;
00154 
00155     <span class="comment">/* For use by watchdog. */</span>
00156     <span class="keywordtype">int</span> resync_frame;
00157 
00158     <span class="comment">/* For use by exit handler functions. */</span>
00159     XHDL *ExitHook;
00160     <span class="keywordtype">int</span> linux_signal;
00161     <span class="keywordtype">int</span> errno;
00162     void (*linux_signal_handler)(<span class="keywordtype">int</span> sig);
00163     RTIME exectime[2];
00164     <span class="keyword">struct </span>mcb_t mcb;
00165 
00166         <span class="comment">/* Real time heaps. */</span>
00167         <span class="keyword">struct </span>rt_heap_t heap[2];
00168 
00169 } RT_TASK __attribute__ ((__aligned__ (16)));
00170 
00171 <span class="preprocessor">#else </span><span class="comment">/* __cplusplus */</span>
00172 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00173 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00174 
00175 <span class="keywordtype">int</span> <a class="code" href="group__lxrt.html#ga6">rt_task_init</a>(<span class="keyword">struct</span> rt_task_struct *task,
00176                  <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00177                  <span class="keywordtype">int</span> data,
00178                  <span class="keywordtype">int</span> stack_size,
00179                  <span class="keywordtype">int</span> priority,
00180                  <span class="keywordtype">int</span> uses_fpu,
00181                  <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00182 
00183 <span class="keywordtype">int</span> rt_task_init_cpuid(<span class="keyword">struct</span> rt_task_struct *task,
00184                        <span class="keywordtype">void</span> (*rt_thread)(<span class="keywordtype">int</span>),
00185                        <span class="keywordtype">int</span> data,
00186                        <span class="keywordtype">int</span> stack_size,
00187                        <span class="keywordtype">int</span> priority,
00188                        <span class="keywordtype">int</span> uses_fpu,
00189                        <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00190                        <span class="keywordtype">unsigned</span> run_on_cpu);
00191 
00192 <span class="keywordtype">void</span> rt_set_runnable_on_cpus(<span class="keyword">struct</span> rt_task_struct *task,
00193                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask);
00194 
00195 <span class="keywordtype">void</span> rt_set_runnable_on_cpuid(<span class="keyword">struct</span> rt_task_struct *task,
00196                               <span class="keywordtype">unsigned</span> cpuid);
00197 
00198 <span class="keywordtype">void</span> rt_set_sched_policy(<span class="keyword">struct</span> rt_task_struct *task,
00199                          <span class="keywordtype">int</span> policy,
00200                          <span class="keywordtype">int</span> rr_quantum_ns);
00201 
00202 <span class="keywordtype">int</span> rt_task_delete(<span class="keyword">struct</span> rt_task_struct *task);
00203 
00204 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a19">rt_get_task_state</a>(<span class="keyword">struct</span> rt_task_struct *task);
00205 
00206 <span class="keywordtype">void</span> rt_gettimeorig(RTIME time_orig[]);
00207 
00208 <span class="keywordtype">int</span> rt_get_timer_cpu(<span class="keywordtype">void</span>);
00209 
00210 <span class="keywordtype">int</span> rt_is_hard_timer_running(<span class="keywordtype">void</span>);
00211 
00212 <span class="keywordtype">void</span> rt_set_periodic_mode(<span class="keywordtype">void</span>);
00213 
00214 <span class="keywordtype">void</span> rt_set_oneshot_mode(<span class="keywordtype">void</span>);
00215 
00216 RTIME start_rt_timer(<span class="keywordtype">int</span> period);
00217 
00218 <span class="preprocessor">#define start_rt_timer_ns(period) start_rt_timer(nano2count((period)))</span>
00219 <span class="preprocessor"></span>
00220 <span class="keywordtype">void</span> start_rt_apic_timers(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode,
00221                           <span class="keywordtype">unsigned</span> rcvr_jiffies_cpuid);
00222 
00223 <span class="keywordtype">void</span> stop_rt_timer(<span class="keywordtype">void</span>);
00224 
00225 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="api_8c.html#a12">rt_whoami</a>(<span class="keywordtype">void</span>);
00226 
00227 <span class="keywordtype">int</span> rt_sched_type(<span class="keywordtype">void</span>);
00228 
00229 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a22">rt_task_signal_handler</a>(<span class="keyword">struct</span> rt_task_struct *task,
00230                            <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>));
00231 
00232 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a21">rt_task_use_fpu</a>(<span class="keyword">struct</span> rt_task_struct *task,
00233                     <span class="keywordtype">int</span> use_fpu_flag);
00234   
00235 <span class="keywordtype">void</span> <a class="code" href="api_8c.html#a20">rt_linux_use_fpu</a>(<span class="keywordtype">int</span> use_fpu_flag);
00236 
00237 <span class="keywordtype">void</span> rt_preempt_always(<span class="keywordtype">int</span> yes_no);
00238 
00239 <span class="keywordtype">void</span> rt_preempt_always_cpuid(<span class="keywordtype">int</span> yes_no,
00240                              <span class="keywordtype">unsigned</span> cpuid);
00241 
00242 RTIME count2nano(RTIME timercounts);
00243 
00244 RTIME nano2count(RTIME nanosecs);
00245   
00246 RTIME count2nano_cpuid(RTIME timercounts,
00247                        <span class="keywordtype">unsigned</span> cpuid);
00248 
00249 RTIME nano2count_cpuid(RTIME nanosecs,
00250                        <span class="keywordtype">unsigned</span> cpuid);
00251   
00252 RTIME rt_get_time(<span class="keywordtype">void</span>);
00253 
00254 RTIME rt_get_time_cpuid(<span class="keywordtype">unsigned</span> cpuid);
00255 
00256 RTIME rt_get_time_ns(<span class="keywordtype">void</span>);
00257 
00258 RTIME rt_get_time_ns_cpuid(<span class="keywordtype">unsigned</span> cpuid);
00259 
00260 RTIME rt_get_cpu_time_ns(<span class="keywordtype">void</span>);
00261 
00262 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a9">rt_get_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00263 
00264 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a10">rt_get_inher_prio</a>(<span class="keyword">struct</span> rt_task_struct *task);
00265 
00266 <span class="keywordtype">void</span> rt_spv_RMS(<span class="keywordtype">int</span> cpuid);
00267 
00268 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a11">rt_change_prio</a>(<span class="keyword">struct</span> rt_task_struct *task,
00269                    <span class="keywordtype">int</span> priority);
00270 
00271 <span class="keywordtype">void</span> rt_sched_lock(<span class="keywordtype">void</span>);
00272 
00273 <span class="keywordtype">void</span> rt_sched_unlock(<span class="keywordtype">void</span>);
00274 
00275 <span class="keywordtype">void</span> <a class="code" href="api_8c.html#a13">rt_task_yield</a>(<span class="keywordtype">void</span>);
00276 
00277 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a14">rt_task_suspend</a>(<span class="keyword">struct</span> rt_task_struct *task);
00278 
00279 <span class="keywordtype">int</span> rt_task_suspend_if(<span class="keyword">struct</span> rt_task_struct *task);
00280 
00281 <span class="keywordtype">int</span> rt_task_suspend_until(<span class="keyword">struct</span> rt_task_struct *task, RTIME until);
00282 
00283 <span class="keywordtype">int</span> rt_task_suspend_timed(<span class="keyword">struct</span> rt_task_struct *task, RTIME delay);
00284 
00285 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a18">rt_task_resume</a>(<span class="keyword">struct</span> rt_task_struct *task);
00286 
00287 <span class="keywordtype">int</span> rt_irq_wait(<span class="keywordtype">unsigned</span> irq);
00288 
00289 <span class="keywordtype">int</span> rt_irq_wait_if(<span class="keywordtype">unsigned</span> irq);
00290 
00291 <span class="keywordtype">int</span> rt_irq_wait_until(<span class="keywordtype">unsigned</span> irq, RTIME until);
00292 
00293 <span class="keywordtype">int</span> rt_irq_wait_timed(<span class="keywordtype">unsigned</span> irq, RTIME delay);
00294 
00295 <span class="keywordtype">void</span> rt_irq_signal(<span class="keywordtype">unsigned</span> irq);
00296 
00297 <span class="keywordtype">int</span> rt_request_irq_task (<span class="keywordtype">unsigned</span> irq, <span class="keywordtype">void</span> *handler, <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> affine2task);
00298 
00299 <span class="keywordtype">int</span> rt_release_irq_task (<span class="keywordtype">unsigned</span> irq);
00300 
00301 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a24">rt_task_make_periodic_relative_ns</a>(<span class="keyword">struct</span> rt_task_struct *task,
00302                                       RTIME start_delay,
00303                                       RTIME period);
00304 
00305 <span class="keywordtype">int</span> <a class="code" href="api_8c.html#a25">rt_task_make_periodic</a>(<span class="keyword">struct</span> rt_task_struct *task,
00306                           RTIME start_time,
00307                           RTIME period);
00308 
00309 <span class="keywordtype">void</span> rt_task_set_resume_end_times(RTIME resume,
00310                                   RTIME end);
00311 
00312 <span class="keywordtype">int</span> rt_set_resume_time(<span class="keyword">struct</span> rt_task_struct *task,
00313                        RTIME new_resume_time);
00314 
00315 <span class="keywordtype">int</span> rt_set_period(<span class="keyword">struct</span> rt_task_struct *task,
00316                   RTIME new_period);
00317 
00318 <span class="keywordtype">void</span> <a class="code" href="api_8c.html#a26">rt_task_wait_period</a>(<span class="keywordtype">void</span>);
00319 
00320 <span class="keywordtype">void</span> rt_schedule(<span class="keywordtype">void</span>);
00321 
00322 RTIME <a class="code" href="api_8c.html#a30">next_period</a>(<span class="keywordtype">void</span>);
00323 
00324 <span class="keywordtype">void</span> <a class="code" href="api_8c.html#a31">rt_busy_sleep</a>(<span class="keywordtype">int</span> nanosecs);
00325 
00326 <span class="keywordtype">void</span> <a class="code" href="api_8c.html#a32">rt_sleep</a>(RTIME delay);
00327 
00328 <span class="keywordtype">void</span> <a class="code" href="api_8c.html#a33">rt_sleep_until</a>(RTIME time);
00329 
00330 <span class="keywordtype">int</span> rt_task_wakeup_sleeping(<span class="keyword">struct</span> rt_task_struct *task);
00331 
00332 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00333                                           <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00334                                           <span class="keywordtype">int</span> data,
00335                                           <span class="keywordtype">int</span> stack_size,
00336                                           <span class="keywordtype">int</span> prio,
00337                                           <span class="keywordtype">int</span> uses_fpu,
00338                                           <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>));
00339 
00340 <span class="keyword">struct </span>rt_task_struct *rt_named_task_init_cpuid(<span class="keyword">const</span> <span class="keywordtype">char</span> *task_name,
00341                                                 <span class="keywordtype">void</span> (*thread)(<span class="keywordtype">int</span>),
00342                                                 <span class="keywordtype">int</span> data,
00343                                                 <span class="keywordtype">int</span> stack_size,
00344                                                 <span class="keywordtype">int</span> prio,
00345                                                 <span class="keywordtype">int</span> uses_fpu,
00346                                                 <span class="keywordtype">void</span>(*signal)(<span class="keywordtype">void</span>),
00347                                                 <span class="keywordtype">unsigned</span> run_on_cpu);
00348 
00349 <span class="keywordtype">int</span> rt_named_task_delete(<span class="keyword">struct</span> rt_task_struct *task);
00350 
00351 RT_TRAP_HANDLER rt_set_task_trap_handler(<span class="keyword">struct</span> rt_task_struct *task,
00352                                          <span class="keywordtype">unsigned</span> vec,
00353                                          RT_TRAP_HANDLER handler);
00354 
00355 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timeval2count(<span class="keyword">struct</span> timeval *t)
00356 {
00357         <span class="keywordflow">return</span> nano2count(t-&gt;tv_sec*1000000000LL + t-&gt;tv_usec*1000);
00358 }
00359 
00360 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timeval(RTIME rt, <span class="keyword">struct</span> timeval *t)
00361 {
00362         t-&gt;tv_sec = ulldiv(count2nano(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_usec);
00363         t-&gt;tv_usec /= 1000;
00364 }
00365 
00366 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2count(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00367 {
00368         <span class="keywordflow">return</span> nano2count(t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec);
00369 }
00370 
00371 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> count2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00372 {
00373         t-&gt;tv_sec = ulldiv(count2nano(rt), 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00374 }
00375 
00376 <span class="keyword">static</span> <span class="keyword">inline</span> RTIME timespec2nanos(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *t)
00377 {
00378         <span class="keywordflow">return</span> t-&gt;tv_sec*1000000000LL + t-&gt;tv_nsec;
00379 }
00380 
00381 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> nanos2timespec(RTIME rt, <span class="keyword">struct</span> timespec *t)
00382 {
00383         t-&gt;tv_sec = ulldiv(rt, 1000000000, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;t-&gt;tv_nsec);
00384 }
00385 
00386 <span class="preprocessor">#ifdef __cplusplus</span>
00387 <span class="preprocessor"></span>}
00388 <span class="preprocessor">#else </span><span class="comment">/* !__cplusplus */</span>
00389 
00390 <span class="comment">/* FIXME: These calls should move to rtai_schedcore.h */</span>
00391 
00392 RT_TASK *rt_get_base_linux_task(RT_TASK **base_linux_task);
00393 
00394 RT_TASK *rt_alloc_dynamic_task(<span class="keywordtype">void</span>);
00395 
00396 <span class="keywordtype">void</span> rt_enq_ready_edf_task(RT_TASK *ready_task);
00397 
00398 <span class="keywordtype">void</span> rt_enq_ready_task(RT_TASK *ready_task);
00399 
00400 <span class="keywordtype">int</span> rt_renq_ready_task(RT_TASK *ready_task,
00401                        <span class="keywordtype">int</span> priority);
00402 
00403 <span class="keywordtype">void</span> rt_rem_ready_task(RT_TASK *task);
00404 
00405 <span class="keywordtype">void</span> rt_rem_ready_current(RT_TASK *rt_current);
00406 
00407 <span class="keywordtype">void</span> rt_enq_timed_task(RT_TASK *timed_task);
00408 
00409 <span class="keywordtype">void</span> rt_rem_timed_task(RT_TASK *task);
00410 
00411 <span class="keywordtype">void</span> rt_dequeue_blocked(RT_TASK *task);
00412 
00413 RT_TASK **rt_register_watchdog(RT_TASK *wdog,
00414                                <span class="keywordtype">int</span> cpuid);
00415 
00416 <span class="keywordtype">void</span> rt_deregister_watchdog(RT_TASK *wdog,
00417                             <span class="keywordtype">int</span> cpuid);
00418 
00419 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00420 
00421 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00422 
00423 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00424 <span class="preprocessor"></span>
00425 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_task_struct {
00426     <span class="keywordtype">int</span> opaque;
00427 } RT_TASK;
00428 
00429 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueBlock {
00430     <span class="keywordtype">int</span> opaque;
00431 } QBLK;
00432 
00433 <span class="keyword">typedef</span> <span class="keyword">struct </span>QueueHook {
00434     <span class="keywordtype">int</span> opaque;
00435 } QHOOK;
00436 
00437 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00438 
00439 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_SCHED_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:52 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
