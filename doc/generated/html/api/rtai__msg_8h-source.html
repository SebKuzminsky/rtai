<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_msg.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a></div>
<h1>rtai_msg.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2002 POSEIDON CONTROLS INC &lt;pcloutier@poseidoncontrols.com&gt;</span>
00003 <span class="comment"> *                    Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00006 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00007 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00008 <span class="comment"> * License, or (at your option) any later version.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00013 <span class="comment"> * GNU General Public License for more details.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00016 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00017 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00018 <span class="comment"> */</span>
00019 
00020 <span class="preprocessor">#ifndef _RTAI_MSG_H</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_MSG_H</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#include &lt;rtai_types.h&gt;</span>
00024 
00025 <span class="preprocessor">#define MSG_ERR ((RT_TASK *)0xFfff)</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#define MAX_NAME_LENGTH  32</span>
00028 <span class="preprocessor"></span>
00029 <span class="keyword">struct </span>rt_task_struct;
00030 <span class="keyword">struct </span>QueueBlock;
00031 <span class="keyword">struct </span>QueueHook;
00032 
00033 <span class="preprocessor">#ifdef __KERNEL__</span>
00034 <span class="preprocessor"></span>
00035 <span class="keyword">typedef</span> <span class="keyword">struct </span>t_msgcb { <span class="comment">/* Message control block structure. */</span>
00036     <span class="keywordtype">int</span>  cmd;
00037     <span class="keywordtype">void</span> *sbuf;
00038     size_t sbytes;
00039     <span class="keywordtype">void</span> *rbuf;
00040     size_t rbytes;
00041 } MSGCB;
00042 
00043 <span class="preprocessor">#define PROXY_MIN_STACK_SIZE 2048</span>
00044 <span class="preprocessor"></span>
00045 <span class="keyword">struct </span>proxy_t {
00046 
00047     <span class="keyword">struct </span>rt_task_struct *receiver;
00048     <span class="keywordtype">int</span> nmsgs,
00049         nbytes;
00050     <span class="keywordtype">char</span> *msg;
00051 };
00052 
00053 <span class="preprocessor">#define SYNCMSG          0</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define PROXY           -1</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#ifdef __cplusplus</span>
00057 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00058 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00059 
00060 <span class="keywordtype">int</span> __rtai_msg_init(<span class="keywordtype">void</span>);
00061 
00062 <span class="keywordtype">void</span> __rtai_msg_exit(<span class="keywordtype">void</span>);
00063 
00064 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga0">rt_send</a>(<span class="keyword">struct</span> rt_task_struct *task,
00065                                <span class="keywordtype">unsigned</span> msg);
00066 
00067 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga1">rt_send_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00068                                   <span class="keywordtype">unsigned</span> msg);
00069 
00070 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga2">rt_send_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00071                                      <span class="keywordtype">unsigned</span> msg,
00072                                      RTIME time);
00073     
00074 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga3">rt_send_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00075                                      <span class="keywordtype">unsigned</span> msg,
00076                                      RTIME delay);
00077 
00078 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga4">rt_evdrp</a>(<span class="keyword">struct</span> rt_task_struct *task,
00079                                 <span class="keywordtype">unsigned</span> *msg);
00080 
00081 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga5">rt_receive</a>(<span class="keyword">struct</span> rt_task_struct *task,
00082                                   <span class="keywordtype">unsigned</span> *msg);
00083 
00084 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga6">rt_receive_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00085                                      <span class="keywordtype">unsigned</span> *msg);
00086 
00087 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga7">rt_receive_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00088                                         <span class="keywordtype">unsigned</span> *msg,
00089                                         RTIME time);
00090 
00091 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga8">rt_receive_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00092                                         <span class="keywordtype">unsigned</span> *msg,
00093                                         RTIME delay);
00094 
00095 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga0">rt_rpc</a>(<span class="keyword">struct</span> rt_task_struct *task,
00096                               <span class="keywordtype">unsigned</span> to_do,
00097                               <span class="keywordtype">unsigned</span> *result);
00098 
00099 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga1">rt_rpc_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00100                                  <span class="keywordtype">unsigned</span> to_do,
00101                                  <span class="keywordtype">unsigned</span> *result);
00102 
00103 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga2">rt_rpc_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00104                                     <span class="keywordtype">unsigned</span> to_do,
00105                                     <span class="keywordtype">unsigned</span> *result,
00106                                     RTIME time);
00107 
00108 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga3">rt_rpc_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00109                                     <span class="keywordtype">unsigned</span> to_do,
00110                                     <span class="keywordtype">unsigned</span> *result,
00111                                     RTIME delay);
00112 
00113 <span class="keywordtype">int</span> <a class="code" href="group__rpc.html#ga4">rt_isrpc</a>(<span class="keyword">struct</span> rt_task_struct *task);
00114 
00115 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga5">rt_return</a>(<span class="keyword">struct</span> rt_task_struct *task,
00116                                  <span class="keywordtype">unsigned</span> result);
00117 
00118 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="msg_8c.html#a21">rt_rpcx</a>(<span class="keyword">struct</span> rt_task_struct *task,
00119                                <span class="keywordtype">void</span> *smsg,
00120                                <span class="keywordtype">void</span> *rmsg,
00121                                <span class="keywordtype">int</span> ssize,
00122                                <span class="keywordtype">int</span> rsize);
00123 
00124 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="msg_8c.html#a22">rt_rpcx_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00125                                   <span class="keywordtype">void</span> *smsg,
00126                                   <span class="keywordtype">void</span> *rmsg,
00127                                   <span class="keywordtype">int</span> ssize,
00128                                   <span class="keywordtype">int</span> rsize);
00129 
00130 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga6">rt_rpcx_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00131                                      <span class="keywordtype">void</span> *smsg,
00132                                      <span class="keywordtype">void</span> *rmsg,
00133                                      <span class="keywordtype">int</span> ssize,
00134                                      <span class="keywordtype">int</span> rsize,
00135                                      RTIME time);
00136 
00137 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga7">rt_rpcx_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00138                                      <span class="keywordtype">void</span> *smsg,
00139                                      <span class="keywordtype">void</span> *rmsg,
00140                                      <span class="keywordtype">int</span> ssize,
00141                                      <span class="keywordtype">int</span> rsize,
00142                                      RTIME delay);
00143 
00144 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga9">rt_sendx</a>(<span class="keyword">struct</span> rt_task_struct *task,
00145                                 <span class="keywordtype">void</span> *msg,
00146                                 <span class="keywordtype">int</span> size);
00147 
00148 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga10">rt_sendx_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00149                                    <span class="keywordtype">void</span> *msg,
00150                                    <span class="keywordtype">int</span> size);
00151 
00152 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga11">rt_sendx_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00153                                       <span class="keywordtype">void</span> *msg,
00154                                       <span class="keywordtype">int</span> size,
00155                                       RTIME time);
00156 
00157 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga12">rt_sendx_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00158                                       <span class="keywordtype">void</span> *msg,
00159                                       <span class="keywordtype">int</span> size,
00160                                       RTIME delay);
00161 
00162 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__rpc.html#ga8">rt_returnx</a>(<span class="keyword">struct</span> rt_task_struct *task,
00163                                   <span class="keywordtype">void</span> *msg,
00164                                   <span class="keywordtype">int</span> size);
00165 
00166 <span class="preprocessor">#define rt_isrpcx(task) rt_isrpc(task)</span>
00167 <span class="preprocessor"></span>
00168 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga13">rt_evdrpx</a>(<span class="keyword">struct</span> rt_task_struct *task,
00169                                  <span class="keywordtype">void</span> *msg,
00170                                  <span class="keywordtype">int</span> size,
00171                                  <span class="keywordtype">int</span> *len);
00172 
00173 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga14">rt_receivex</a>(<span class="keyword">struct</span> rt_task_struct *task,
00174                                    <span class="keywordtype">void</span> *msg,
00175                                    <span class="keywordtype">int</span> size,
00176                                    <span class="keywordtype">int</span> *len);
00177 
00178 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga15">rt_receivex_if</a>(<span class="keyword">struct</span> rt_task_struct *task,
00179                                       <span class="keywordtype">void</span> *msg,
00180                                       <span class="keywordtype">int</span> size,
00181                                       <span class="keywordtype">int</span> *len);
00182 
00183 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga16">rt_receivex_until</a>(<span class="keyword">struct</span> rt_task_struct *task,
00184                                          <span class="keywordtype">void</span> *msg,
00185                                          <span class="keywordtype">int</span> size,
00186                                          <span class="keywordtype">int</span> *len,
00187                                          RTIME time);
00188 
00189 <span class="keyword">struct </span>rt_task_struct *<a class="code" href="group__msg.html#ga17">rt_receivex_timed</a>(<span class="keyword">struct</span> rt_task_struct *task,
00190                                          <span class="keywordtype">void</span> *msg,
00191                                          <span class="keywordtype">int</span> size,
00192                                          <span class="keywordtype">int</span> *len,
00193                                          RTIME delay);
00194 
00195 <span class="keyword">struct </span>rt_task_struct *__rt_proxy_attach(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">int</span>),
00196                                          <span class="keyword">struct</span> rt_task_struct *task,
00197                                          <span class="keywordtype">void</span> *msg,
00198                                          <span class="keywordtype">int</span> nbytes,
00199                                          <span class="keywordtype">int</span> priority);
00200 
00201 <span class="keyword">struct </span>rt_task_struct *rt_proxy_attach(<span class="keyword">struct</span> rt_task_struct *task,
00202                                        <span class="keywordtype">void</span> *msg,
00203                                        <span class="keywordtype">int</span> nbytes,
00204                                        <span class="keywordtype">int</span> priority);
00205 
00206 <span class="keywordtype">int</span> rt_proxy_detach(<span class="keyword">struct</span> rt_task_struct *proxy);
00207 
00208 <span class="keyword">struct </span>rt_task_struct *rt_trigger(<span class="keyword">struct</span> rt_task_struct *proxy);
00209 
00210 <span class="preprocessor">#define exist(name)  rt_get_adr(nam2num(name))</span>
00211 <span class="preprocessor"></span>
00212 <span class="keywordtype">int</span> rt_Send(pid_t pid,
00213             <span class="keywordtype">void</span> *smsg,
00214             <span class="keywordtype">void</span> *rmsg,
00215             size_t ssize,
00216             size_t rsize);
00217 
00218 pid_t rt_Receive(pid_t pid,
00219                  <span class="keywordtype">void</span> *msg,
00220                  size_t maxsize,
00221                  size_t *msglen);
00222 
00223 pid_t rt_Creceive(pid_t pid,
00224                   <span class="keywordtype">void</span> *msg,
00225                   size_t maxsize,
00226                   size_t *msglen,
00227                   RTIME delay);
00228 
00229 <span class="keywordtype">int</span> rt_Reply(pid_t pid,
00230              <span class="keywordtype">void</span> *msg,
00231              size_t size);
00232 
00233 pid_t rt_Proxy_attach(pid_t pid,
00234                       <span class="keywordtype">void</span> *msg,
00235                       <span class="keywordtype">int</span> nbytes,
00236                       <span class="keywordtype">int</span> priority);
00237 
00238 <span class="keywordtype">int</span> rt_Proxy_detach(pid_t pid);
00239 
00240 pid_t rt_Trigger(pid_t pid);
00241 
00242 pid_t rt_Name_attach(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
00243 
00244 pid_t rt_Name_locate(<span class="keyword">const</span> <span class="keywordtype">char</span> *host,
00245                      <span class="keyword">const</span> <span class="keywordtype">char</span> *name);
00246 
00247 <span class="keywordtype">int</span> rt_Name_detach(pid_t pid);
00248 
00249 <span class="preprocessor">#ifdef __cplusplus</span>
00250 <span class="preprocessor"></span>}
00251 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00252 
00253 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00254 
00255 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00256 
00257 <span class="preprocessor">#ifdef __cplusplus</span>
00258 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00259 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00260 
00261 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg))
00262 {
00263         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; } arg = { task, msg };
00264         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDMSG, &amp;arg).v[LOW];
00265 }
00266 
00267 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg))
00268 {
00269         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; } arg = { task, msg };
00270         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SEND_IF, &amp;arg).v[LOW];
00271 }
00272 
00273 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg, RTIME time))
00274 {
00275         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; RTIME time; } arg = { task, msg, time };
00276         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SEND_UNTIL, &amp;arg).v[LOW];
00277 }
00278 
00279 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_send_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> msg, RTIME delay))
00280 {
00281         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> msg; RTIME delay; } arg = { task, msg, delay };
00282         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SEND_TIMED, &amp;arg).v[LOW];
00283 }
00284 
00285 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_evdrp,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg))
00286 {
00287         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; } arg = { task, msg };
00288         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, EVDRP, &amp;arg).v[LOW];
00289 }
00290 
00291 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg))
00292 {
00293         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; } arg = { task, msg };
00294         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEMSG, &amp;arg).v[LOW];
00295 }
00296 
00297 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg))
00298 {
00299         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; } arg = { task, msg };
00300         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVE_IF, &amp;arg).v[LOW];
00301 }
00302 
00303 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg, RTIME time))
00304 {
00305         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; RTIME time; } arg = { task, msg, time };
00306         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVE_UNTIL, &amp;arg).v[LOW];
00307 }
00308 
00309 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receive_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> *msg, RTIME delay))
00310 {
00311         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> *msg; RTIME delay; } arg = { task, msg, delay };
00312         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVE_TIMED, &amp;arg).v[LOW];
00313 }
00314 
00315 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result))
00316 {
00317         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; } arg = { task, to_do, result };
00318         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCMSG, &amp;arg).v[LOW];
00319 }
00320 
00321 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result))
00322 {
00323         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; } arg = { task, to_do, result };
00324         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPC_IF, &amp;arg).v[LOW];
00325 }
00326 
00327 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result, RTIME time))
00328 {
00329         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; RTIME time; } arg = { task, to_do, result, time };
00330         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPC_UNTIL, &amp;arg).v[LOW];
00331 }
00332 
00333 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpc_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> to_do, <span class="keywordtype">unsigned</span> *result, RTIME delay))
00334 {
00335         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> to_do; <span class="keywordtype">unsigned</span> *result; RTIME delay; } arg = { task, to_do, result, delay };
00336         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPC_TIMED, &amp;arg).v[LOW];
00337 }
00338 
00339 RTAI_PROTO(<span class="keywordtype">int</span>, rt_isrpc,(<span class="keyword">struct</span> rt_task_struct *task))
00340 {
00341         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; } arg = { task };
00342         <span class="keywordflow">return</span> (int)rtai_lxrt(BIDX, SIZARG, ISRPC, &amp;arg).i[LOW];
00343 }
00344 
00345 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_return,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">unsigned</span> result))
00346 {
00347         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">unsigned</span> result; } arg = { task, result };
00348         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RETURNMSG, &amp;arg).v[LOW];
00349 }
00350 
00351 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize))
00352 {
00353         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00354         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX, &amp;arg).v[LOW];
00355 }
00356 
00357 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize))
00358 {
00359         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; } arg = { task, smsg, rmsg, ssize, rsize };
00360         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX_IF, &amp;arg).v[LOW];
00361 }
00362 
00363 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME time))
00364 {
00365         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME time; } arg = { task, smsg, rmsg, ssize, rsize, time };
00366         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX_UNTIL, &amp;arg).v[LOW];
00367 }
00368 
00369 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_rpcx_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, <span class="keywordtype">int</span> ssize, <span class="keywordtype">int</span> rsize, RTIME delay))
00370 {
00371         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; <span class="keywordtype">int</span> ssize; <span class="keywordtype">int</span> rsize; RTIME delay; } arg = { task, smsg, rmsg, ssize, rsize, delay };
00372         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RPCX_TIMED, &amp;arg).v[LOW];
00373 }
00374 
00375 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size))
00376 {
00377         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00378         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX, &amp;arg).v[LOW];
00379 }
00380 
00381 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size))
00382 {
00383         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00384         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX_IF, &amp;arg).v[LOW];
00385 }
00386 
00387 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME time))
00388 {
00389         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME time; } arg = { task, msg, size, time };
00390         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX_UNTIL, &amp;arg).v[LOW];
00391 }
00392 
00393 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_sendx_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, RTIME delay))
00394 {
00395         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; RTIME delay; } arg = { task, msg, size, delay };
00396         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, SENDX_TIMED, &amp;arg).v[LOW];
00397 }
00398 
00399 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_returnx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size))
00400 {
00401         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size; } arg = { task, msg, size };
00402         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RETURNX, &amp;arg).v[LOW];
00403 }
00404 
00405 <span class="preprocessor">#define rt_isrpcx(task)  rt_isrpc(task)</span>
00406 <span class="preprocessor"></span>
00407 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_evdrpx,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len))
00408 {
00409         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; } arg = { task, msg, size, len };
00410         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, EVDRPX, &amp;arg).v[LOW];
00411 }
00412 
00413 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len))
00414 {
00415         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; } arg = { task, msg, size, len };
00416         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX, &amp;arg).v[LOW];
00417 }
00418 
00419 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex_if,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len))
00420 {
00421         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; } arg = { task, msg, size, len };
00422         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX_IF, &amp;arg).v[LOW];
00423 }
00424 
00425 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex_until,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME time))
00426 {
00427         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; RTIME time; } arg = { task, msg, size, len, time };
00428         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX_UNTIL, &amp;arg).v[LOW];
00429 }
00430 
00431 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_receivex_timed,(<span class="keyword">struct</span> rt_task_struct *task, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> *len, RTIME delay))
00432 {
00433         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *task; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> size, *len; RTIME delay; } arg = { task, msg, size, len, delay };
00434         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *)rtai_lxrt(BIDX, SIZARG, RECEIVEX_TIMED, &amp;arg).v[LOW];
00435 }
00436 
00437 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_proxy_attach,(<span class="keyword">struct</span> rt_task_struct *proxy, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> nbytes, <span class="keywordtype">int</span> priority))
00438 {
00439         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *proxy; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> nbytes, priority;} arg = { proxy, msg, nbytes, priority };
00440         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *) rtai_lxrt(BIDX, SIZARG, PROXY_ATTACH, &amp;arg).v[LOW];
00441 }
00442 
00443 RTAI_PROTO(<span class="keywordtype">int</span>, rt_proxy_detach,(<span class="keyword">struct</span> rt_task_struct *proxy))
00444 {
00445         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *proxy; } arg = { proxy };
00446         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, PROXY_DETACH, &amp;arg).i[LOW];
00447 }
00448 
00449 RTAI_PROTO(<span class="keyword">struct</span> rt_task_struct *,rt_trigger,(<span class="keyword">struct</span> rt_task_struct *proxy))
00450 {
00451         <span class="keyword">struct </span>{ <span class="keyword">struct </span>rt_task_struct *proxy; } arg = { proxy };
00452         <span class="keywordflow">return</span> (<span class="keyword">struct </span>rt_task_struct *) rtai_lxrt(BIDX, SIZARG, PROXY_TRIGGER, &amp;arg).v[LOW];
00453 }
00454 
00455 RTAI_PROTO(<span class="keywordtype">int</span>, rt_Send,(pid_t pid, <span class="keywordtype">void</span> *smsg, <span class="keywordtype">void</span> *rmsg, size_t ssize, size_t rsize ))
00456 {
00457         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *smsg; <span class="keywordtype">void</span> *rmsg; size_t ssize, rsize;} arg = { pid, smsg, rmsg, ssize, rsize };
00458         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_SEND, &amp;arg).i[LOW];
00459 }
00460 
00461 RTAI_PROTO(pid_t, rt_Receive,(pid_t pid, <span class="keywordtype">void</span> *msg, size_t maxsize, size_t *msglen))
00462 {
00463         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; size_t maxsize, *msglen;}
00464         arg = { pid, msg, maxsize, msglen };
00465         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_RECEIVE, &amp;arg).i[LOW];
00466 }
00467 
00468 RTAI_PROTO(pid_t, rt_Creceive,(pid_t pid, <span class="keywordtype">void</span> *msg, size_t maxsize, size_t *msglen, RTIME delay))
00469 {
00470         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; size_t maxsize, *msglen; RTIME delay;} arg = { pid, msg, maxsize, msglen, delay };
00471         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_CRECEIVE, &amp;arg).i[LOW];
00472 }
00473 
00474 RTAI_PROTO(pid_t, rt_Reply,(pid_t pid, <span class="keywordtype">void</span> *msg, size_t size))
00475 {
00476         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; size_t size;} arg = { pid, msg, size };
00477         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_REPLY, &amp;arg).i[LOW];
00478 }
00479 
00480 RTAI_PROTO(pid_t, rt_Proxy_attach,(pid_t pid, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> nbytes, <span class="keywordtype">int</span> priority))
00481 {
00482         <span class="keyword">struct </span>{ pid_t pid; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> nbytes, priority;} arg = { pid, msg, nbytes, priority };
00483         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_PROXY_ATTACH, &amp;arg).i[LOW];
00484 }
00485 
00486 RTAI_PROTO(pid_t, rt_Proxy_detach,(pid_t pid))
00487 {
00488         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00489         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_PROXY_DETACH, &amp;arg).i[LOW];
00490 }
00491 
00492 RTAI_PROTO(pid_t, rt_Trigger,(pid_t pid))
00493 {
00494         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00495         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_TRIGGER, &amp;arg).i[LOW];
00496 }
00497 
00498 RTAI_PROTO(pid_t, rt_Alias_attach,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00499 {
00500         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *name; } arg = { name};
00501         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_NAME_ATTACH, &amp;arg).i[LOW];
00502 }
00503 
00504 RTAI_PROTO(pid_t, rt_Name_locate,(<span class="keyword">const</span> <span class="keywordtype">char</span> *host, <span class="keyword">const</span> <span class="keywordtype">char</span> *name))
00505 {
00506         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *host, *name; } arg = { host, name };
00507         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_NAME_LOCATE, &amp;arg).i[LOW];
00508 }
00509 
00510 RTAI_PROTO(<span class="keywordtype">int</span>, rt_Name_detach,(pid_t pid))
00511 {
00512         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00513         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_NAME_DETACH, &amp;arg).i[LOW];
00514 }
00515 
00516 RTAI_PROTO(<span class="keywordtype">int</span>, rt_InitTickQueue,(<span class="keywordtype">void</span>))
00517 {
00518         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00519         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_INITTICKQUEUE, &amp;arg).i[LOW];
00520 }
00521 
00522 RTAI_PROTO(<span class="keywordtype">void</span>, rt_ReleaseTickQueue,(<span class="keywordtype">void</span>))
00523 {
00524         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00525         rtai_lxrt(BIDX, SIZARG, RT_RELEASETICKQUEUE, &amp;arg);
00526 }
00527 
00528 RTAI_PROTO(<span class="keywordtype">unsigned</span>, rt_qDynAlloc,(<span class="keywordtype">unsigned</span> n))
00529 {
00530         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> n; } arg = { n };
00531         <span class="keywordflow">return</span> (unsigned) rtai_lxrt(BIDX, SIZARG, RT_QDYNALLOC, &amp;arg).i[LOW];
00532 } 
00533 
00534 RTAI_PROTO(<span class="keywordtype">unsigned</span>, rt_qDynFree,(<span class="keywordtype">int</span> n))
00535 {
00536         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> n; } arg = { n };
00537         <span class="keywordflow">return</span> (unsigned) rtai_lxrt(BIDX, SIZARG, RT_QDYNFREE, &amp;arg).i[LOW];
00538 }
00539 
00540 RTAI_PROTO(<span class="keyword">struct</span> QueueBlock *,rt_qDynInit,(<span class="keyword">struct</span> QueueBlock **q, <span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>), <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn ))
00541 {
00542         <span class="keyword">struct </span>QueueBlock *r;
00543 
00544         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock **q; void (*fun)(<span class="keywordtype">void</span> *, int), *data; <span class="keywordtype">int</span> evn; } arg = { 0, fun, data, evn };
00545         r  = (<span class="keyword">struct </span>QueueBlock *) rtai_lxrt(BIDX, SIZARG, RT_QDYNINIT, &amp;arg).v[LOW];
00546         <span class="keywordflow">if</span> (q) *q = r;
00547         <span class="keywordflow">return</span> r;
00548 }
00549 
00550 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkWait,(<span class="keyword">struct</span> QueueBlock *q, RTIME t))
00551 {
00552         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; RTIME t; } arg = { q, t } ;
00553         rtai_lxrt(BIDX, SIZARG, RT_QBLKWAIT, &amp;arg);
00554 }
00555 
00556 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkRepeat,(<span class="keyword">struct</span> QueueBlock *q, RTIME t))
00557 {
00558         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; RTIME t; } arg = { q, t } ;
00559         rtai_lxrt(BIDX, SIZARG, RT_QBLKREPEAT, &amp;arg);
00560 }
00561 
00562 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkSoon,(<span class="keyword">struct</span> QueueBlock *q))
00563 {
00564         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00565         rtai_lxrt(BIDX, SIZARG, RT_QBLKSOON, &amp;arg);
00566 }
00567 
00568 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkDequeue,(<span class="keyword">struct</span> QueueBlock *q))
00569 {
00570         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00571         rtai_lxrt(BIDX, SIZARG, RT_QBLKDEQUEUE, &amp;arg);
00572 }
00573 
00574 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkCancel,(<span class="keyword">struct</span> QueueBlock *q))
00575 {
00576         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00577         rtai_lxrt(BIDX, SIZARG, RT_QBLKCANCEL, &amp;arg);
00578 }
00579 
00580 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkBefore,(<span class="keyword">struct</span> QueueBlock *cur, <span class="keyword">struct</span> QueueBlock *nxt))
00581 {
00582         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *cur, *nxt; } arg = { cur, nxt };
00583         rtai_lxrt(BIDX, SIZARG, RT_QBLKBEFORE, &amp;arg);
00584 }
00585 
00586 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkAfter,(<span class="keyword">struct</span> QueueBlock *cur, <span class="keyword">struct</span> QueueBlock *prv))
00587 {
00588         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *cur, *prv; } arg = { cur, prv };
00589         rtai_lxrt(BIDX, SIZARG, RT_QBLKAFTER, &amp;arg);
00590 }
00591 
00592 RTAI_PROTO(<span class="keyword">struct</span> QueueBlock *,rt_qBlkUnhook,(<span class="keyword">struct</span> QueueBlock *q))
00593 {
00594         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00595         <span class="keywordflow">return</span> (<span class="keyword">struct </span>QueueBlock *) rtai_lxrt(BIDX, SIZARG, RT_QBLKUNHOOK, &amp;arg).v[LOW];
00596 }
00597 
00598 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkRelease,(<span class="keyword">struct</span> QueueBlock *q))
00599 {
00600         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00601         rtai_lxrt(BIDX, SIZARG, RT_QBLKRELEASE, &amp;arg);
00602 }
00603 
00604 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkComplete,(<span class="keyword">struct</span> QueueBlock *q))
00605 {
00606         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; } arg = { q };
00607         rtai_lxrt(BIDX, SIZARG, RT_QBLKCOMPLETE, &amp;arg);
00608 }
00609 
00610 RTAI_PROTO(<span class="keywordtype">int</span>, rt_qSync,(<span class="keywordtype">void</span>))
00611 {
00612         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00613         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_QSYNC, &amp;arg).i[LOW];
00614 }
00615 
00616 RTAI_PROTO(pid_t, rt_qReceive,(pid_t target, <span class="keywordtype">void</span> *buf, size_t maxlen, size_t *msglen))
00617 {
00618         <span class="keyword">struct </span>{pid_t target; <span class="keywordtype">void</span> *buf; size_t maxlen, *msglen; } arg = { target, buf, maxlen, msglen };
00619         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_QRECEIVE, &amp;arg).i[LOW];
00620 }
00621 
00622 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qLoop,(<span class="keywordtype">void</span>))
00623 {
00624         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00625         rtai_lxrt(BIDX, SIZARG, RT_QLOOP, &amp;arg);
00626 }
00627 
00628 RTAI_PROTO(RTIME, rt_qStep,(<span class="keywordtype">void</span>))
00629 {
00630         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00631         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_QSTEP, &amp;arg).rt;
00632 }
00633 
00634 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qHookFlush,(<span class="keyword">struct</span> QueueHook *h))
00635 {
00636         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueHook *h; } arg = { h };
00637         rtai_lxrt(BIDX, SIZARG, RT_QHOOKFLUSH, &amp;arg);
00638 }
00639 
00640 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkAtHead,(<span class="keyword">struct</span> QueueBlock *q, <span class="keyword">struct</span> QueueHook *h))
00641 {
00642         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; <span class="keyword">struct </span>QueueHook *h; } arg = { q, h };
00643         rtai_lxrt(BIDX, SIZARG, RT_QBLKATHEAD, &amp;arg);
00644 }
00645 
00646 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkAtTail,(<span class="keyword">struct</span> QueueBlock *q, <span class="keyword">struct</span> QueueHook *h))
00647 {
00648         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; <span class="keyword">struct </span>QueueHook *h; } arg = { q, h };
00649         rtai_lxrt(BIDX, SIZARG, RT_QBLKATTAIL, &amp;arg);
00650 }
00651 
00652 RTAI_PROTO(<span class="keyword">struct</span> QueueHook *,rt_qHookInit,(<span class="keyword">struct</span> QueueHook **h, <span class="keywordtype">void</span> (*c)(<span class="keywordtype">void</span> *, <span class="keyword">struct</span> QueueBlock *), <span class="keywordtype">void</span> *a))
00653 {
00654         <span class="keyword">struct </span>QueueHook *r;
00655         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueHook **h; void (*c)(<span class="keywordtype">void</span> *, <span class="keyword">struct </span>QueueBlock *), *a;} arg = { 0, c, a };
00656         r = (<span class="keyword">struct </span>QueueHook *) rtai_lxrt(BIDX, SIZARG, RT_QHOOKINIT, &amp;arg).v[LOW];
00657         <span class="keywordflow">if</span> (h) *h = r;
00658         <span class="keywordflow">return</span> r;
00659 }
00660 
00661 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qHookRelease,(<span class="keyword">struct</span> QueueHook *h))
00662 {
00663         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueHook *h; } arg = { h };
00664         rtai_lxrt(BIDX, SIZARG, RT_QHOOKRELEASE, &amp;arg);
00665 }
00666 
00667 RTAI_PROTO(<span class="keywordtype">void</span>, rt_qBlkSchedule,(<span class="keyword">struct</span> QueueBlock *q, RTIME t))
00668 {
00669         <span class="keyword">struct </span>{ <span class="keyword">struct </span>QueueBlock *q; RTIME t; } arg = { q, t } ;
00670         rtai_lxrt(BIDX, SIZARG, RT_QBLKSCHEDULE, &amp;arg);
00671 }
00672 
00673 RTAI_PROTO(<span class="keyword">struct</span> QueueHook *,rt_GetTickQueueHook,(<span class="keywordtype">void</span>))
00674 {
00675         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00676         <span class="keywordflow">return</span> (<span class="keyword">struct </span>QueueHook *) rtai_lxrt(BIDX, SIZARG, RT_GETTICKQUEUEHOOK, &amp;arg).v[LOW];
00677 }
00678 
00679 RTAI_PROTO(pid_t, rt_vc_reserve,( <span class="keywordtype">void</span> ))
00680 {
00681         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00682         <span class="keywordflow">return</span> (pid_t) rtai_lxrt(BIDX, SIZARG, RT_VC_RESERVE, &amp;arg).i[LOW];
00683 }
00684 
00685 RTAI_PROTO(<span class="keywordtype">int</span>, rt_vc_attach,(pid_t pid))
00686 {
00687         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00688         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_VC_ATTACH, &amp;arg).i[LOW];
00689 }
00690 
00691 RTAI_PROTO(<span class="keywordtype">int</span>, rt_vc_release,(pid_t pid))
00692 {
00693         <span class="keyword">struct </span>{ pid_t pid; } arg = { pid };
00694         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_VC_RELEASE, &amp;arg).i[LOW];
00695 }
00696 
00697 <span class="preprocessor">#ifdef __cplusplus</span>
00698 <span class="preprocessor"></span>}
00699 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00700 
00701 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00702 
00703 <span class="preprocessor">#if !defined(__KERNEL__) || defined(__cplusplus)</span>
00704 <span class="preprocessor"></span>
00705 <span class="keyword">typedef</span> <span class="keyword">struct </span>t_msgcb {
00706     <span class="keywordtype">int</span> opaque;
00707 } MSGCB;
00708 
00709 <span class="preprocessor">#endif </span><span class="comment">/* !__KERNEL__ || __cplusplus */</span>
00710 
00711 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_MSG_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:52 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
